diff --git a/arch/arm/mach-aspeed/include/mach/ast2400_platform.h b/arch/arm/mach-aspeed/include/mach/ast2400_platform.h
index fad9bbc..f01f971 100644
--- a/arch/arm/mach-aspeed/include/mach/ast2400_platform.h
+++ b/arch/arm/mach-aspeed/include/mach/ast2400_platform.h
@@ -99,11 +99,11 @@
 
 #define AST_LPC_BRIDGE						0x60000000
 
-#define ASR_VIDEO_MEM_SIZE				0x2800000		//40MB
-#define ASR_VIDEO_MEM 					(AST_DRAM_BASE + (SZ_8M*10))//(AST_DRAM_BASE + SZ_256M)
+#define AST_VIDEO_MEM_SIZE				0x2800000		//40MB
+#define AST_VIDEO_MEM 					(AST_DRAM_BASE + (SZ_8M*20))//(AST_DRAM_BASE + SZ_256M)
 
 #define AST_CRT0_MEM_SIZE				SZ_8M
-#define AST_CRT0_MEM_BASE				(ASR_VIDEO_MEM + ASR_VIDEO_MEM_SIZE)
+#define AST_CRT0_MEM_BASE				(AST_VIDEO_MEM + AST_VIDEO_MEM_SIZE)
 
 #define AST_CURSOR0_MEM_SIZE			SZ_1M
 #define AST_CURSOR0_MEM_BASE			(AST_CRT0_MEM_BASE + AST_CRT0_MEM_SIZE)
diff --git a/arch/arm/plat-aspeed/dev-fb.c b/arch/arm/plat-aspeed/dev-fb.c
index 6725edb..3da0c46 100644
--- a/arch/arm/plat-aspeed/dev-fb.c
+++ b/arch/arm/plat-aspeed/dev-fb.c
@@ -191,7 +191,7 @@ void __init ast_add_device_fb(void)
 	ast_scu_multi_func_crt();
 	ast_scu_init_crt();
 	
-	fb_plat_data.clock_src = ast_get_clk_source();
+//	fb_plat_data.clock_src = ast_get_clk_source();
 
 	platform_device_register(&ast_fb0_device);
 #ifdef AST_CRT1_BASE	
diff --git a/arch/arm/plat-aspeed/dev-i2c.c b/arch/arm/plat-aspeed/dev-i2c.c
index 36892b4..2d176cd 100644
--- a/arch/arm/plat-aspeed/dev-i2c.c
+++ b/arch/arm/plat-aspeed/dev-i2c.c
@@ -925,28 +925,28 @@ static struct i2c_board_info ast_i2c_board_info_7[] __initdata = {
 //Under I2C Dev 8
 static struct i2c_board_info ast_i2c_board_info_8[] __initdata = {
   // FRUID
-  {
-    I2C_BOARD_INFO("24c64", 0x51),
-  },
+  // {
+  //   I2C_BOARD_INFO("24c64", 0x51),
+  // },
 };
 
 //Under I2C Dev 9
 static struct i2c_board_info ast_i2c_board_info_9[] __initdata = {
   // Inlet and Outlet temp. sensors
-  {
-    I2C_BOARD_INFO("tmp421", 0x4e),
-  },
-  {
-    I2C_BOARD_INFO("tmp421", 0x4f),
-  },
+  // {
+  //   I2C_BOARD_INFO("tmp421", 0x4e),
+  // },
+  // {
+  //   I2C_BOARD_INFO("tmp421", 0x4f),
+  // },
 };
 
 //Under I2C Dev 10
 static struct i2c_board_info ast_i2c_board_info_10[] __initdata = {
   // Hotswap Sensor
-  {
-    I2C_BOARD_INFO("adm1278", 0x40),
-  },
+  // {
+  //   I2C_BOARD_INFO("adm1278", 0x40),
+  // },
 };
 
 //Under I2C Dev 11
@@ -960,9 +960,9 @@ static struct i2c_board_info ast_i2c_board_info_11[] __initdata = {
 //Under I2C Dev 12
 static struct i2c_board_info ast_i2c_board_info_12[] __initdata = {
   // Mezz Card Mezz_SMB bus (FRUID, GPIO expander, QSFP+)
-  {
-    I2C_BOARD_INFO("24c64", 0x51),
-  },
+  // {
+  //   I2C_BOARD_INFO("24c64", 0x51),
+  // },
 };
 
 /* end of CONFIG_YOSEMITE */
@@ -1273,12 +1273,12 @@ void __init ast_add_device_i2c(void)
 	platform_device_register(&ast_i2c_dev5_device_1M);
 	platform_device_register(&ast_i2c_dev6_device);
 	platform_device_register(&ast_i2c_dev7_device_1M);
-	platform_device_register(&ast_i2c_dev8_device);
-	platform_device_register(&ast_i2c_dev9_device);
-	platform_device_register(&ast_i2c_dev10_device);
-	platform_device_register(&ast_i2c_dev11_device);
-	platform_device_register(&ast_i2c_dev12_device);
-	platform_device_register(&ast_i2c_dev13_device);
+	// platform_device_register(&ast_i2c_dev8_device);
+	// platform_device_register(&ast_i2c_dev9_device);
+	// platform_device_register(&ast_i2c_dev10_device);
+	// platform_device_register(&ast_i2c_dev11_device);
+	// platform_device_register(&ast_i2c_dev12_device);
+	// platform_device_register(&ast_i2c_dev13_device);
 
 	i2c_register_board_info(0, ast_i2c_board_info_0,
 		              ARRAY_SIZE(ast_i2c_board_info_0));
@@ -1296,16 +1296,16 @@ void __init ast_add_device_i2c(void)
                   ARRAY_SIZE(ast_i2c_board_info_6));
 	i2c_register_board_info(7, ast_i2c_board_info_7,
                   ARRAY_SIZE(ast_i2c_board_info_7));
-	i2c_register_board_info(8, ast_i2c_board_info_8,
-		              ARRAY_SIZE(ast_i2c_board_info_8));
-	i2c_register_board_info(9, ast_i2c_board_info_9,
-                  ARRAY_SIZE(ast_i2c_board_info_9));
-	i2c_register_board_info(10, ast_i2c_board_info_10,
-                  ARRAY_SIZE(ast_i2c_board_info_10));
-	i2c_register_board_info(11, ast_i2c_board_info_11,
-                  ARRAY_SIZE(ast_i2c_board_info_11));
-	i2c_register_board_info(12, ast_i2c_board_info_12,
-                  ARRAY_SIZE(ast_i2c_board_info_12));
+	// i2c_register_board_info(8, ast_i2c_board_info_8,
+	// 	              ARRAY_SIZE(ast_i2c_board_info_8));
+	// i2c_register_board_info(9, ast_i2c_board_info_9,
+ //                  ARRAY_SIZE(ast_i2c_board_info_9));
+	// i2c_register_board_info(10, ast_i2c_board_info_10,
+ //                  ARRAY_SIZE(ast_i2c_board_info_10));
+	// i2c_register_board_info(11, ast_i2c_board_info_11,
+ //                  ARRAY_SIZE(ast_i2c_board_info_11));
+	// i2c_register_board_info(12, ast_i2c_board_info_12,
+ //                  ARRAY_SIZE(ast_i2c_board_info_12));
 }
 
 #elif defined(CONFIG_LIGHTNING)
diff --git a/arch/arm/plat-aspeed/dev-video.c b/arch/arm/plat-aspeed/dev-video.c
index ad23d04..5f7b0d8 100644
--- a/arch/arm/plat-aspeed/dev-video.c
+++ b/arch/arm/plat-aspeed/dev-video.c
@@ -88,9 +88,13 @@ struct platform_device ast_video_device = {
 
 void __init ast_add_device_video(void)
 {
+printk("trace video 1\n");
 	ast_scu_init_video(0);
+printk("trace video 2\n");
 	ast_scu_multi_func_video();
+printk("trace video 3\n");
 	platform_device_register(&ast_video_device);
+printk("trace video 4\n");
 }
 #else
 void __init ast_add_device_video(void) {}
diff --git a/arch/arm/plat-aspeed/devs.c b/arch/arm/plat-aspeed/devs.c
index f1dfab2..678f393 100644
--- a/arch/arm/plat-aspeed/devs.c
+++ b/arch/arm/plat-aspeed/devs.c
@@ -72,7 +72,7 @@ init_fnc_t __initdata *init_all_device[] = {
 	//ast_add_device_uhci,
 	//ast_add_device_udc11,
 	//ast_add_device_hid,
-	//ast_add_device_video,
+	ast_add_device_video,
 	//ast_add_device_fb,
 	ast_add_device_kcs,
 	ast_add_device_bt,
diff --git a/drivers/net/ethernet/faraday/ftgmac100.c b/drivers/net/ethernet/faraday/ftgmac100.c
index 7074f1a..0fbd8b9 100644
--- a/drivers/net/ethernet/faraday/ftgmac100.c
+++ b/drivers/net/ethernet/faraday/ftgmac100.c
@@ -2234,7 +2234,8 @@ void ncsi_start(struct net_device *dev) {
         //TODO: This is an issue in  Get_Version_ID that always returns
         //mezz_type to be -1, so it only calls Get_MAC_Address_bcm.
         //It may need to work with Mlx to find a solution.
-#if defined(CONFIG_FBY2) || defined(CONFIG_YOSEMITE)    //For multi-host NIC initialization
+// #if defined(CONFIG_FBY2) || defined(CONFIG_YOSEMITE)    //For multi-host NIC initialization
+#if defined(CONFIG_FBY2)    //For multi-host NIC initialization
         // Try Mlx first
         Get_MAC_Address_mlx(dev);
         Set_MAC_Affinity_mlx(dev);
@@ -2261,7 +2262,8 @@ void ncsi_start(struct net_device *dev) {
           Get_MAC_Address_bcm(dev);
           mdelay(500);
         } else {
-          Get_MAC_Address_intel(dev);
+          // Get_MAC_Address_intel(dev);
+          Get_MAC_Address_bcm(dev);
           mdelay(500);
         }
 
diff --git a/drivers/soc/aspeed/ast_video.c b/drivers/soc/aspeed/ast_video.c
index eb0989d..ebd71a5 100644
--- a/drivers/soc/aspeed/ast_video.c
+++ b/drivers/soc/aspeed/ast_video.c
@@ -1,27 +1,28 @@
-/********************************************************************************
-* File Name     : ast_video.c
-* Author         : Ryan Chen
-* Description   : AST Video Engine Controller
-* 
-* Copyright (C) 2012-2020  ASPEED Technology Inc.
-* This program is free software; you can redistribute it and/or modify 
-* it under the terms of the GNU General Public License as published by the Free Software Foundation; 
-* either version 2 of the License, or (at your option) any later version. 
-* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; 
-* without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. 
-* You should have received a copy of the GNU General Public License 
-* along with this program; if not, write to the Free Software 
-* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
-*
-*   Version      : 1.0
-*   History      : 
-*      1. 2013/04/30 Ryan Chen create this file 
-*    
-********************************************************************************/
+/*
+ * ast-video.c - Video driver for the Aspeed SoC
+ *
+ * Copyright (C) ASPEED Technology Inc.
+ * Ryan Chen <ryan_chen@aspeedtech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
 
 #include <linux/slab.h>
 #include <linux/sched.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
 
 #include <linux/module.h>
 #include <linux/fs.h>
@@ -32,51 +33,529 @@
 #include <linux/mm.h>
 #include <linux/delay.h>
 #include <linux/miscdevice.h>
-
 #include <linux/hwmon-sysfs.h>
-
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/dma-mapping.h>
 #include <asm/io.h>
+#include <linux/of.h>
+#include <linux/of_reserved_mem.h>
 #include <asm/uaccess.h>
-#include <plat/regs-video.h>
-#include <mach/ast_video.h>
-#include <mach/hardware.h>
+#include <linux/aspeed-sdmc.h>
+#include <linux/ast_lcd.h>
+#include <linux/fb.h>
+
+/***********************************************************************/
+/* Register for VIDEO */
+#define AST_VIDEO_PROTECT		0x000		/*	protection key register	*/
+#define AST_VIDEO_SEQ_CTRL		0x004		/*	Video Sequence Control register	*/
+#define AST_VIDEO_PASS_CTRL		0x008		/*	Video Pass 1 Control register	*/
+
+//VR008[5]=1
+#define AST_VIDEO_DIRECT_BASE	0x00C		/*	Video Direct Frame buffer mode control Register VR008[5]=1 */
+#define AST_VIDEO_DIRECT_CTRL	0x010		/*	Video Direct Frame buffer mode control Register VR008[5]=1 */
+
+//VR008[5]=0
+#define AST_VIDEO_TIMING_H		0x00C		/*	Video Timing Generation Setting Register */
+#define AST_VIDEO_TIMING_V		0x010		/*	Video Timing Generation Setting Register */
+#define AST_VIDEO_SCAL_FACTOR	0x014		/*	Video Scaling Factor Register */
+
+#define AST_VIDEO_SCALING0		0x018		/*	Video Scaling Filter Parameter Register #0 */
+#define AST_VIDEO_SCALING1		0x01C		/*	Video Scaling Filter Parameter Register #1 */
+#define AST_VIDEO_SCALING2		0x020		/*	Video Scaling Filter Parameter Register #2 */
+#define AST_VIDEO_SCALING3		0x024		/*	Video Scaling Filter Parameter Register #3 */
+
+#define AST_VIDEO_BCD_CTRL		0x02C		/*	Video BCD Control Register */
+#define AST_VIDEO_CAPTURE_WIN	0x030		/*	 Video Capturing Window Setting Register */
+#define AST_VIDEO_COMPRESS_WIN	0x034		/*	 Video Compression Window Setting Register */
+
+
+#define AST_VIDEO_COMPRESS_PRO	0x038		/* Video Compression Stream Buffer Processing Offset Register */
+#define AST_VIDEO_COMPRESS_READ	0x03C		/* Video Compression Stream Buffer Read Offset Register */
+
+#define AST_VIDEO_JPEG_HEADER_BUFF		0x040		/*	Video Based Address of JPEG Header Buffer Register */
+#define AST_VIDEO_SOURCE_BUFF0	0x044		/*	Video Based Address of Video Source Buffer #1 Register */
+#define AST_VIDEO_SOURCE_SCAN_LINE	0x048		/*	Video Scan Line Offset of Video Source Buffer Register */
+#define AST_VIDEO_SOURCE_BUFF1	0x04C		/*	Video Based Address of Video Source Buffer #2 Register */
+#define AST_VIDEO_BCD_BUFF		0x050		/*	Video Base Address of BCD Flag Buffer Register */
+#define AST_VIDEO_STREAM_BUFF	0x054		/*	Video Base Address of Compressed Video Stream Buffer Register */
+#define AST_VIDEO_STREAM_SIZE	0x058		/*	Video Stream Buffer Size Register */
+
+#define AST_VIDEO_COMPRESS_CTRL	0x060		/* Video Compression Control Register */
+
+
+#define AST_VIDEO_COMPRESS_DATA_COUNT		0x070		/* Video Total Size of Compressed Video Stream Read Back Register */
+#define AST_VIDEO_COMPRESS_BLOCK_COUNT		0x074		/* Video Total Number of Compressed Video Block Read Back Register */
+#define AST_VIDEO_COMPRESS_FRAME_END		0x078		/* Video Frame-end offset of compressed video stream buffer read back Register */
+
+
 
+#define AST_VIDEO_DEF_HEADER	0x080		/* Video User Defined Header Parameter Setting with Compression */
+#define AST_VIDEO_JPEG_COUNT	0x084		/* true jpeg size */
+
+#define AST_VIDEO_H_DETECT_STS  0x090		/* Video Source Left/Right Edge Detection Read Back Register */
+#define AST_VIDEO_V_DETECT_STS  0x094		/* Video Source Top/Bottom Edge Detection Read Back Register */
+
+
+#define AST_VIDEO_MODE_DET_STS	0x098		/* Video Mode Detection Status Read Back Register */
+
+#define AST_VIDEO_MODE_DET1		0x0A4		/* Video Mode Detection Control Register 1*/
+
+#define AST_VM_SEQ_CTRL			0x204		/* Video Management Control Sequence Register */
+#define AST_VM_PASS_CTRL			0x208		/* Video Management Pass 1 Control register	*/
+#define AST_VM_SCAL_FACTOR		0x214		/* Video Management Scaling Factor Register */
+#define AST_VM_BCD_CTRL			0x22C		/* Video Management BCD Control Register */
+#define AST_VM_CAPTURE_WIN		0x230		/* Video Management Capturing Window Setting Register */
+#define AST_VM_COMPRESS_WIN		0x234		/* Video Management Compression Window Setting Register */
+#define AST_VM_JPEG_HEADER_BUFF	0x240		/* Video Management Based Address of JPEG Header Buffer Register */
+#define AST_VM_SOURCE_BUFF0		0x244		/* Video Management Based Address of Video Source Buffer Register */
+#define AST_VM_SOURCE_SCAN_LINE	0x248		/* Video Management Scan Line Offset of Video Source Buffer Register */
+
+#define AST_VM_COMPRESS_BUFF		0x254		/* Video Management Based Address of Compressed Video Buffer Register */
+#define AST_VM_STREAM_SIZE			0x258		/* Video Management Buffer Size Register */
+#define AST_VM_COMPRESS_CTRL			0x260		/* Video Management Compression or Video Profile 2-5 Decompression Control Register */
+#define AST_VM_COMPRESS_VR264			0x264		/* VR264 REserved */
+#define AST_VM_COMPRESS_BLOCK_COUNT		0x274		/* Video Total Number of Compressed Video Block Read Back Register */
+#define AST_VM_COMPRESS_FRAME_END	0x278	/*16 bytes align */	/* Video Management Frame-end offset of compressed video stream buffer read back Register */
+
+
+#define AST_VIDEO_CTRL			0x300		/* Video Control Register */
+#define AST_VIDEO_INT_EN		0x304		/* Video interrupt Enable */
+#define AST_VIDEO_INT_STS		0x308		/* Video interrupt status */
+#define AST_VIDEO_MODE_DETECT	0x30C		/* Video Mode Detection Parameter Register */
+
+#define AST_VIDEO_CRC1 			0x320		/* Primary CRC Parameter Register */
+#define AST_VIDEO_CRC2 			0x324		/* Second CRC Parameter Register */
+#define AST_VIDEO_DATA_TRUNCA	0x328		/* Video Data Truncation Register */
+
+
+#define AST_VIDEO_SCRATCH_340	0x340		/* Video Scratch Remap Read Back */
+#define AST_VIDEO_SCRATCH_344	0x344		/* Video Scratch Remap Read Back */
+#define AST_VIDEO_SCRATCH_348	0x348		/* Video Scratch Remap Read Back */
+#define AST_VIDEO_SCRATCH_34C	0x34C		/* Video Scratch Remap Read Back */
+#define AST_VIDEO_SCRATCH_350	0x350		/* Video Scratch Remap Read Back */
+#define AST_VIDEO_SCRATCH_354	0x354		/* Video Scratch Remap Read Back */
+#define AST_VIDEO_SCRATCH_358	0x358		/* Video Scratch Remap Read Back */
+#define AST_VIDEO_SCRATCH_35C	0x35C		/* Video Scratch Remap Read Back */
+#define AST_VIDEO_SCRATCH_360	0x360		/* Video Scratch Remap Read Back */
+#define AST_VIDEO_SCRATCH_364	0x364		/* Video Scratch Remap Read Back */
+
+
+#define AST_VIDEO_ENCRYPT_SRAM	0x400		/* Video RC4/AES128 Encryption Key Register #0 ~ #63 */
+
+/////////////////////////////////////////////////////////////////////////////
+
+/*	AST_VIDEO_PROTECT: 0x000  - protection key register */
+#define VIDEO_PROTECT_UNLOCK			0x1A038AA8
+
+/*	AST_VIDEO_SEQ_CTRL		0x004		Video Sequence Control register	*/
+#define VIDEO_HALT_ENG_STS				(1 << 21)
+#define VIDEO_COMPRESS_BUSY				(1 << 18)
+#define VIDEO_CAPTURE_BUSY				(1 << 16)
+#define VIDEO_HALT_ENG_TRIGGER			(1 << 12)
+#define VIDEO_COMPRESS_FORMAT_MASK		(3 << 10)
+#define VIDEO_GET_COMPRESS_FORMAT(x)		((x >> 10) & 0x3)   // 0 YUV444
+#define VIDEO_COMPRESS_FORMAT(x)		(x << 10)	// 0 YUV444
+#define YUV420		1
+
+#define G5_VIDEO_COMPRESS_JPEG_MODE			(1 << 13)
+#define VIDEO_YUV2RGB_DITHER_EN			(1 << 8)
+
+#define VIDEO_COMPRESS_JPEG_MODE			(1 << 8)
+
+//if bit 0 : 1
+#define VIDEO_INPUT_MODE_CHG_WDT		(1 << 7)
+#define VIDEO_INSERT_FULL_COMPRESS		(1 << 6)
+#define VIDEO_AUTO_COMPRESS				(1 << 5)
+#define VIDEO_COMPRESS_TRIGGER			(1 << 4)
+#define VIDEO_CAPTURE_MULTI_FRAME		(1 << 3)
+#define VIDEO_COMPRESS_FORCE_IDLE		(1 << 2)
+#define VIDEO_CAPTURE_TRIGGER			(1 << 1)
+#define VIDEO_DETECT_TRIGGER			(1 << 0)
+
+
+#define VIDEO_HALT_ENG_RB				(1 << 21)
+#define VIDEO_HALT_ENG_RB				(1 << 21)
+#define VIDEO_HALT_ENG_RB				(1 << 21)
+#define VIDEO_HALT_ENG_RB				(1 << 21)
+#define VIDEO_HALT_ENG_RB				(1 << 21)
+#define VIDEO_HALT_ENG_RB				(1 << 21)
+
+
+/*	AST_VIDEO_PASS_CTRL			0x008		Video Pass1 Control register	*/
+//x * source frame rate / 60
+#define VIDEO_FRAME_RATE_CTRL(x)		(x << 16)
+#define VIDEO_HSYNC_POLARITY_CTRL		(1 << 15)
+#define VIDEO_INTERLANCE_MODE			(1 << 14)
+#define VIDEO_DUAL_EDGE_MODE			(1 << 13)	//0 : Single edage
+#define VIDEO_18BIT_SINGLE_EDGE			(1 << 12)	//0: 24bits
+#define VIDEO_DVO_INPUT_DELAY_MASK		(7 << 9)
+#define VIDEO_DVO_INPUT_DELAY(x)		(x << 9) //0 : no delay , 1: 1ns, 2: 2ns, 3:3ns, 4: inversed clock but no delay
+// if biit 5 : 0
+#define VIDEO_HW_CURSOR_DIS				(1 << 8)
+// if biit 5 : 1
+#define VIDEO_AUTO_FATCH					(1 << 8)	//
+#define VIDEO_CAPTURE_FORMATE_MASK		(3 << 6)
+
+#define VIDEO_SET_CAPTURE_FORMAT(x)			(x << 6)
+#define JPEG_MODE		1
+#define RGB_MODE		2
+#define GRAY_MODE		3
+#define VIDEO_DIRT_FATCH				(1 << 5)
+// if biit 5 : 0
+#define VIDEO_INTERNAL_DE				(1 << 4)
+#define VIDEO_EXT_ADC_ATTRIBUTE			(1 << 3)
+
+// if biit 5 : 1
+#define VIDEO_16BPP_MODE				(1 << 4)
+#define VIDEO_16BPP_MODE_555			(1 << 3)	//0:565
+
+#define VIDEO_FROM_EXT_SOURCE			(1 << 2)
+#define VIDEO_SO_VSYNC_POLARITY			(1 << 1)
+#define VIDEO_SO_HSYNC_POLARITY			(1 << 0)
+
+/*	AST_VIDEO_TIMING_H		0x00C		Video Timing Generation Setting Register */
+#define VIDEO_HSYNC_PIXEL_FIRST_SET(x)	(((x) & 0xfff) << 16)
+#define VIDEO_HSYNC_PIXEL_FIRST_MASK	0xFFFF0000
+#define VIDEO_HSYNC_PIXEL_LAST_SET(x)	((x) & 0xfff)
+#define VIDEO_HSYNC_PIXEL_LAST_MASK	0x0000FFFF
+
+
+/*	AST_VIDEO_DIRECT_CTRL	0x010		Video Direct Frame buffer mode control Register VR008[5]=1 */
+#define VIDEO_FETCH_TIMING(x)			((x) << 16)
+#define VIDEO_FETCH_LINE_OFFSET(x)		(x & 0xffff)
+
+/*	AST_VIDEO_TIMING_V		0x010		Video Timing Generation Setting Register */
+#define VIDEO_VSYNC_PIXEL_FIRST_SET(x)	((x) << 16)
+#define VIDEO_VSYNC_PIXEL_LAST_SET(x)	(x)
+
+
+/*	AST_VIDEO_SCAL_FACTOR	0x014		Video Scaling Factor Register */
+#define VIDEO_V_SCAL_FACTOR(x)			(((x) & 0xffff) << 16)
+#define VIDEO_V_SCAL_FACTOR_MASK		(0x0000ffff)
+#define VIDEO_H_SCAL_FACTOR(x)			((x) & 0xffff)
+#define VIDEO_H_SCAL_FACTOR_MASK		(0xffff0000)
+
+
+
+/*	AST_VIDEO_SCALING0		0x018		Video Scaling Filter Parameter Register #0 */
+/*	AST_VIDEO_SCALING1		0x01C		Video Scaling Filter Parameter Register #1 */
+/*	AST_VIDEO_SCALING2		0x020		Video Scaling Filter Parameter Register #2 */
+/*	AST_VIDEO_SCALING3		0x024		Video Scaling Filter Parameter Register #3 */
+
+
+/*	AST_VIDEO_BCD_CTRL		0x02C		Video BCD Control Register */
+#define VIDEO_SET_ABCD_TOL(x)			((x & 0xff) << 24)
+#define VIDEO_GET_ABCD_TOL(x)			((x >> 24) & 0xff)
+#define VIDEO_SET_BCD_TOL(x)			((x & 0xff) << 16)
+#define VIDEO_GET_BCD_TOL(x)			((x >> 16) & 0xff)
+
+#define VIDEO_ABCD_CHG_EN				(1 << 1)
+#define VIDEO_BCD_CHG_EN				(1)
+
+
+
+/*	 AST_VIDEO_CAPTURE_WIN	0x030		Video Capturing Window Setting Register */
+#define VIDEO_CAPTURE_V(x)				(x & 0x7ff)
+#define VIDEO_CAPTURE_H(x)				((x & 0x7ff) << 16)
+
+/*	 AST_VIDEO_COMPRESS_WIN	0x034		Video Compression Window Setting Register */
+#define VIDEO_COMPRESS_V(x)				(x & 0x7ff)
+#define VIDEO_GET_COMPRESS_V(x)			(x & 0x7ff)
+#define VIDEO_COMPRESS_H(x)				((x & 0x7ff) << 16)
+#define VIDEO_GET_COMPRESS_H(x)			((x >> 16) & 0x7ff)
+
+
+
+/*	AST_VIDEO_RESET :0x03c	 - system reset control register */
+
+/*	AST_VIDEO_STREAM_SIZE	0x058		Video Stream Buffer Size Register */
+#define VIDEO_STREAM_PKT_N(x)			(x << 3)
+#define STREAM_4_PKTS		0
+#define STREAM_8_PKTS		1
+#define STREAM_16_PKTS		2
+#define STREAM_32_PKTS		3
+#define STREAM_64_PKTS		4
+#define STREAM_128_PKTS		5
+
+#define VIDEO_STREAM_PKT_SIZE(x)		(x)
+#define STREAM_1KB		0
+#define STREAM_2KB		1
+#define STREAM_4KB		2
+#define STREAM_8KB		3
+#define STREAM_16KB		4
+#define STREAM_32KB		5
+#define STREAM_64KB		6
+#define STREAM_128KB	7
+
+/* AST_VIDEO_COMPRESS_CTRL	0x060		Video Compression Control Register */
+#define VIDEO_HQ_DCT_LUM(x)				((x) << 27)
+#define VIDEO_GET_HQ_DCT_LUM(x)			((x >> 27) & 0x1f)
+#define VIDEO_HQ_DCT_CHROM(x)				((x) << 22)
+#define VIDEO_GET_HQ_DCT_CHROM(x)			((x >> 22) & 0x1f)
+#define VIDEO_HQ_DCT_MASK					(0x3ff << 22)
+#define VIDEO_DCT_HUFFMAN_ENCODE(x)		((x) << 20)
+#define VIDEO_DCT_RESET						(1 << 17)
+#define VIDEO_HQ_ENABLE					(1 << 16)
+#define VIDEO_GET_HQ_ENABLE(x)				((x >> 16) & 0x1)
+#define VIDEO_DCT_LUM(x)					((x) << 11)
+#define VIDEO_GET_DCT_LUM(x)				((x >> 11) & 0x1f)
+#define VIDEO_DCT_CHROM(x)					((x) << 6)
+#define VIDEO_GET_DCT_CHROM(x)			((x >> 6) & 0x1f)
+#define VIDEO_DCT_MASK						(0x3ff << 6)
+#define VIDEO_ENCRYP_ENABLE				(1 << 5)
+#define VIDEO_COMPRESS_QUANTIZ_MODE		(1 << 2)
+#define VIDEO_4COLOR_VQ_ENCODE			(1 << 1)
+#define VIDEO_DCT_ONLY_ENCODE				(1)
+#define VIDEO_DCT_VQ_MASK					(0x3)
+
+/* AST_VIDEO_COMPRESS_BLOCK_COUNT - 0x074		Video Total Number of Compressed Video Block Read Back Register */
+#define GET_BLOCK_CHG(x)				((x >> 16) & 0xffff)
+
+/* AST_VIDEO_H_DETECT_STS  0x090		Video Source Left/Right Edge Detection Read Back Register */
+#define VIDEO_DET_INTERLANCE_MODE		(1 << 31)
+#define VIDEO_GET_HSYNC_RIGHT(x)		((x & 0x0FFF0000) >> 16)
+#define VIDEO_GET_HSYNC_LEFT(x)			(x & 0xFFF)
+#define VIDEO_NO_DISPLAY_CLOCK_DET		(1 << 15)
+#define VIDEO_NO_ACT_DISPLAY_DET		(1 << 14)
+#define VIDEO_NO_HSYNC_DET				(1 << 13)
+#define VIDEO_NO_VSYNC_DET				(1 << 12)
+
+/* AST_VIDEO_V_DETECT_STS  0x094		Video Source Top/Bottom Edge Detection Read Back Register */
+#define VIDEO_GET_VSYNC_BOTTOM(x)		((x & 0x0FFF0000) >> 16)
+#define VIDEO_GET_VSYNC_TOP(x)			(x & 0xFFF)
+
+
+/* AST_VIDEO_MODE_DET_STS	0x098		Video Mode Detection Status Read Back Register */
+#define VIDEO_DET_HSYNC_RDY				(1 << 31)
+#define VIDEO_DET_VSYNC_RDY				(1 << 30)
+#define VIDEO_DET_HSYNC_POLAR			(1 << 29)
+#define VIDEO_DET_VSYNC_POLAR			(1 << 28)
+#define VIDEO_GET_VER_SCAN_LINE(x)		((x >> 16) & 0xfff)
+#define VIDEO_OUT_SYNC					(1 << 15)
+#define VIDEO_DET_VER_STABLE			(1 << 14)
+#define VIDEO_DET_HOR_STABLE			(1 << 13)
+#define VIDEO_DET_FROM_ADC				(1 << 12)
+#define VIDEO_DET_HOR_PERIOD(x)			(x & 0xfff)
+
+
+/* AST_VIDEO_MODE_DET1		0x0A4		Video Mode Detection Control Register 1*/
+#define VIDEO_DET_HSYNC_DELAY_MASK		(0xff << 16)
+#define VIDEO_DET_LONG_H_STABLE_EN		(1 << 29)
+
+/* AST_VM_SEQ_CTRL	0x204		Video Management Control Sequence Register */
+#define VIDEO_VM_SET_YUV420				(1 << 10)
+#define VIDEO_VM_JPEG_COMPRESS_MODE		(1 << 8)
+#define VIDEO_VM_AUTO_COMPRESS			(1 << 5)
+#define VIDEO_VM_COMPRESS_TRIGGER		(1 << 4)
+#define VIDEO_VM_CAPTURE_TRIGGER			(1 << 1)
+
+/* AST_VM_BUFF_SIZE			0x258		Video Management Buffer Size Register */
+#define VM_STREAM_PKT_SIZE(x)		(x)
+#define STREAM_1MB		0
+#define STREAM_2MB		1
+#define STREAM_3MB		2
+#define STREAM_4MB		3
+
+/* AST_VIDEO_CTRL			0x300		Video Control Register */
+#define VIDEO_CTRL_CRYPTO(x)			(x << 17)
+#define VIDEO_CTRL_CRYPTO_AES				(1 << 17)
+#define VIDEO_CTRL_CRYPTO_FAST			(1 << 16)
+//15 reserved
+#define VIDEO_CTRL_RC4_VC				(1 << 14)
+#define VIDEO_CTRL_CAPTURE_MASK			(3 << 12)
+#define VIDEO_CTRL_CAPTURE_MODE(x)		(x << 12)
+#define VIDEO_CTRL_COMPRESS_MASK		(3 << 10)
+#define VIDEO_CTRL_COMPRESS_MODE(x)		(x << 10)
+#define MODE_32BPP_YUV444		0
+#define MODE_24BPP_YUV444		1
+#define MODE_16BPP_YUV422		3
+
+#define VIDEO_CTRL_RC4_TEST_MODE		(1 << 9)
+#define VIDEO_CTRL_RC4_RST				(1 << 8)
+#define VIDEO_CTRL_RC4_VIDEO_M_SEL		(1 << 7)		//video management 
+#define VIDEO_CTRL_RC4_VIDEO_2_SEL		(1 << 6)		// Video 2 
+
+#define VIDEO_CTRL_DWN_SCALING_MASK		(0x3 << 4)
+#define VIDEO_CTRL_DWN_SCALING_ENABLE_LINE_BUFFER		(0x1 << 4)
+
+#define VIDEO_CTRL_VSYNC_DELAY_MASK		(3 << 2)
+#define VIDEO_CTRL_VSYNC_DELAY(x)		(x << 2)
+#define NO_DELAY			0
+#define DELAY_DIV12_HSYNC	1
+#define AUTO_DELAY			2
+
+/* AST_VIDEO_INT_EN			0x304		Video interrupt Enable */
+/* AST_VIDEO_INT_STS		0x308		Video interrupt status */
+#define VM_COMPRESS_COMPLETE			(1 << 17)
+#define VM_CAPTURE_COMPLETE			(1 << 16)
+
+#define VIDEO_FRAME_COMPLETE			(1 << 5)
+#define VIDEO_MODE_DETECT_RDY			(1 << 4)
+#define VIDEO_COMPRESS_COMPLETE			(1 << 3)
+#define VIDEO_COMPRESS_PKT_COMPLETE		(1 << 2)
+#define VIDEO_CAPTURE_COMPLETE			(1 << 1)
+#define VIDEO_MODE_DETECT_WDT			(1 << 0)
+
+/* AST_VIDEO_MODE_DETECT	0x30C		Video Mode Detection Parameter Register */
+#define VIDEO_MODE_HOR_TOLER(x)			(x << 28)
+#define VIDEO_MODE_VER_TOLER(x)			(x << 24)
+#define VIDEO_MODE_HOR_STABLE(x)		(x << 20)
+#define VIDEO_MODE_VER_STABLE(x)		(x << 16)
+#define VIDEO_MODE_EDG_THROD(x)			(x << 8)
+
+#define MODEDETECTION_VERTICAL_STABLE_MAXIMUM       0x6
+#define MODEDETECTION_HORIZONTAL_STABLE_MAXIMUM     0x6
+#define MODEDETECTION_VERTICAL_STABLE_THRESHOLD     0x2
+#define MODEDETECTION_HORIZONTAL_STABLE_THRESHOLD   0x2
+
+/* AST_VIDEO_SCRATCH_34C	0x34C		Video Scratch Remap Read Back */
+#define SCRATCH_VGA_GET_REFLASH_RATE(x)			((x >> 8) & 0xf)
+#define SCRATCH_VGA_GET_COLOR_MODE(x)			((x >> 4) & 0xf)
+
+/* AST_VIDEO_SCRATCH_350	0x350		Video Scratch Remap Read Back */
+#define SCRATCH_VGA_GET_MODE_HEADER(x)			((x >> 8) & 0xff)
+#define SCRATCH_VGA_GET_NEW_COLOR_MODE(x)		((x >> 16) & 0xff)
+#define SCRATCH_VGA_GET_NEW_PIXEL_CLK(x)		((x >> 24) & 0xff)
+
+
+/* AST_VIDEO_SCRATCH_35C	0x35C		Video Scratch Remap Read Back */
+#define SCRATCH_VGA_PWR_STS_HSYNC				(1 << 31)
+#define SCRATCH_VGA_PWR_STS_VSYNC				(1 << 30)
+#define SCRATCH_VGA_ATTRIBTE_INDEX_BIT5			(1 << 29)
+#define SCRATCH_VGA_MASK_REG					(1 << 28)
+#define SCRATCH_VGA_CRT_RST						(1 << 27)
+#define SCRATCH_VGA_SCREEN_OFF					(1 << 26)
+#define SCRATCH_VGA_RESET						(1 << 25)
+#define SCRATCH_VGA_ENABLE						(1 << 24)
+/***********************************************************************/
 //#define CONFIG_AST_VIDEO_LOCK
 #define CONFIG_AUTO_MODE
 
-//#define CONFIG_AST_VIDEO_DEBUG
+#define CONFIG_AST_VIDEO_DEBUG
 
 #ifdef CONFIG_AST_VIDEO_DEBUG
-	#define VIDEO_DBG(fmt, args...) printk("%s(): " fmt, __FUNCTION__, ## args)
+#define VIDEO_DBG(fmt, args...) printk(KERN_DEBUG "%s() " fmt,__FUNCTION__, ## args)
 #else
-	#define VIDEO_DBG(fmt, args...)
+#define VIDEO_DBG(fmt, args...)
 #endif
 
+//VR08[2]
+typedef enum ast_video_source {
+	VIDEO_SOURCE_INT_VGA = 0,
+	VIDEO_SOURCE_INT_CRT,
+	VIDEO_SOURCE_EXT_ADC,
+	VIDEO_SOURCE_EXT_DIGITAL,
+} video_source;
+
+//VR08[5]
+typedef enum ast_vga_mode {
+	VIDEO_VGA_DIRECT_MODE = 0,
+	VIDEO_VGA_CAPTURE_MODE,
+} vga_mode;
+
+//VR08[4]
+typedef enum ast_video_dis_en {
+	VIDEO_EXT_DE_SIGNAL = 0,
+	VIDEO_INT_DE_SIGNAL,
+} display_enable;
+
+typedef enum video_color_format {
+	VIDEO_COLOR_RGB565 = 0,
+	VIDEO_COLOR_RGB888,
+	VIDEO_COLOR_YUV444,
+	VIDEO_COLOR_YUV420,
+} color_formate;
+
+typedef enum vga_color_mode {
+	VGA_NO_SIGNAL = 0,
+	EGA_MODE,
+	VGA_MODE,
+	VGA_15BPP_MODE,
+	VGA_16BPP_MODE,
+	VGA_32BPP_MODE,
+	VGA_CGA_MODE,
+	VGA_TEXT_MODE,
+} color_mode;
+
+typedef enum video_stage {
+	NONE,
+	POLARITY,
+	RESOLUTION,
+	INIT,
+	RUN,
+} stage;
+
 /***********************************************************************/
+struct ast_video_config {
+	u8	engine;					//0: engine 0, engine 1
+	u8	compression_mode; 		//0:DCT, 1:DCT_VQ mix VQ-2 color, 2:DCT_VQ mix VQ-4 color		9:
+	u8	compression_format;		//0:ASPEED 1:JPEG
+	u8	capture_format;			//0:CCIR601-2 YUV, 1:JPEG YUV, 2:RGB for ASPEED mode only, 3:Gray
+	u8	rc4_enable;				//0:disable 1:enable
+	u8 	EncodeKeys[256];
+
+	u8	YUV420_mode;			//0:YUV444, 1:YUV420
+	u8	Visual_Lossless;
+	u8	Y_JPEGTableSelector;
+	u8	AdvanceTableSelector;
+	u8	AutoMode;
+};
+
+struct ast_auto_mode {
+	u8	engine_idx;					//set 0: engine 0, engine 1
+	u8	differential;					//set 0: full, 1:diff frame
+	u8	mode_change;				//get 0: no, 1:change
+	u32	total_size;					//get
+	u32	block_count;					//get
+};
+
+struct ast_capture_mode {
+	u8	engine_idx;					//set 0: engine 0, engine 1
+	u8	differential;					//set 0: full, 1:diff frame
+	u8	mode_change;				//get 0: no, 1:change
+};
+
+struct ast_compression_mode {
+	u8	engine_idx;					//set 0: engine 0, engine 1
+	u8	mode_change;				//get 0: no, 1:change
+	u32	total_size;					//get
+	u32	block_count;					//get
+};
+
+struct ast_scaling {
+	u8	engine;					//0: engine 0, engine 1
+	u8	enable;
+	u16	x;
+	u16	y;
+};
+
+struct ast_mode_detection {
+	unsigned char		result;		//0: pass, 1: fail
+	unsigned short	src_x;
+	unsigned short	src_y;
+};
+
 //IOCTL ..
 #define VIDEOIOC_BASE       'V'
 
-#define AST_VIDEO_IOCRTIMING		_IOR(VIDEOIOC_BASE, 0, struct timing_negotiation*)
-#define AST_VIDEO_IOCWTIMING		_IOW(VIDEOIOC_BASE, 1, struct timing_negotiation*)
-#define AST_VIDEO_IOCXFER			_IOWR(VIDEOIOC_BASE, 2, struct xfer_msg*)
-
-///////////////////////////////////
-#define  IOCTL_IO_READ    0x1103
-#define  IOCTL_IO_WRITE   0x1104
-#define  IOCTL_AUTOMODE_TRIGGER         0x1111
-#define  IOCTL_PASS3_TRIGGER   0x1112
-#define  IOCTL_I2C_READ        0x1113
-#define  IOCTL_I2C_WRITE       0x1114
-
-typedef struct _IO_ACCESS_DATA {
-    unsigned char Type;
-    unsigned long Address;
-    unsigned long Data;
-    unsigned long Value;
-    unsigned long I2CValue;
-    int      kernel_socket;
-} IO_ACCESS_DATA, *PIO_ACCESS_DATA;
+#define AST_VIDEO_RESET							_IO(VIDEOIOC_BASE, 0x0)
+#define AST_VIDEO_IOC_GET_VGA_SIGNAL			_IOR(VIDEOIOC_BASE, 0x1, unsigned char)
+#define AST_VIDEO_GET_MEM_SIZE_IOCRX			_IOR(VIDEOIOC_BASE, 0x2, unsigned long)
+#define AST_VIDEO_GET_JPEG_OFFSET_IOCRX		_IOR(VIDEOIOC_BASE, 0x3, unsigned long)
+#define AST_VIDEO_VGA_MODE_DETECTION			_IOWR(VIDEOIOC_BASE, 0x4, struct ast_mode_detection*)
+
+#define AST_VIDEO_ENG_CONFIG					_IOW(VIDEOIOC_BASE, 0x5, struct ast_video_config*)
+#define AST_VIDEO_SET_SCALING					_IOW(VIDEOIOC_BASE, 0x6, struct ast_scaling*)
 
+#define AST_VIDEO_AUTOMODE_TRIGGER			_IOWR(VIDEOIOC_BASE, 0x7, struct ast_auto_mode*)
+#define AST_VIDEO_CAPTURE_TRIGGER				_IOWR(VIDEOIOC_BASE, 0x8, struct ast_capture_mode*)
+#define AST_VIDEO_COMPRESSION_TRIGGER		_IOWR(VIDEOIOC_BASE, 0x9, struct ast_compression_mode*)
+
+#define AST_VIDEO_SET_VGA_DISPLAY				_IOW(VIDEOIOC_BASE, 0xa, int)
+#define AST_VIDEO_SET_ENCRYPTION				_IOW(VIDEOIOC_BASE, 0xb, int)
+#define AST_VIDEO_SET_ENCRYPTION_KEY			_IOW(VIDEOIOC_BASE, 0xc, unsigned char*)
+#define AST_VIDEO_SET_CRT_COMPRESSION		_IOW(VIDEOIOC_BASE, 0xd, struct fb_var_screeninfo*)
 /***********************************************************************/
 typedef struct {
 	u16	HorizontalActive;
@@ -87,52 +566,29 @@ typedef struct {
 
 INTERNAL_MODE Internal_Mode[] = {
 // 1024x768
-  {1024, 768, 0, 65000},
-  {1024, 768, 1, 65000},
-  {1024, 768, 2, 75000},
-  {1024, 768, 3, 78750},
-  {1024, 768, 4, 94500},
+	{1024, 768, 0, 65000},
+	{1024, 768, 1, 65000},
+	{1024, 768, 2, 75000},
+	{1024, 768, 3, 78750},
+	{1024, 768, 4, 94500},
 // 1280x1024
-  {1280, 1024, 0, 108000},
-  {1280, 1024, 1, 108000},
-  {1280, 1024, 2, 135000},
-  {1280, 1024, 3, 157500},      
+	{1280, 1024, 0, 108000},
+	{1280, 1024, 1, 108000},
+	{1280, 1024, 2, 135000},
+	{1280, 1024, 3, 157500},
 // 1600x1200
-  {1600, 1200, 0, 162000},
-  {1600, 1200, 1, 162000},
-  {1600, 1200, 2, 175500},
-  {1600, 1200, 3, 189000},
-  {1600, 1200, 4, 202500},
-  {1600, 1200, 5, 229500},
+	{1600, 1200, 0, 162000},
+	{1600, 1200, 1, 162000},
+	{1600, 1200, 2, 175500},
+	{1600, 1200, 3, 189000},
+	{1600, 1200, 4, 202500},
+	{1600, 1200, 5, 229500},
 // 1920x1200 reduce blank
-  {1920, 1200, 0, 157000},
-  {1920, 1200, 1, 157000},
+	{1920, 1200, 0, 157000},
+	{1920, 1200, 1, 157000},
 };
 
-typedef struct _TRANSFER_HEADER {
-    u32	Data_Length;
-    u32	Blocks_Changed;
-    u16	User_Width;
-    u16	User_Height;
-    u16	Source_Width;
-    u16	Source_Height;
-    u8		RC4_Enable;
-    u8      RC4_Reset;
-    u8      Y_Table;
-    u8      UV_Table;
-    u8      Mode_420;
-    u8      Direct_Mode;
-    u8      VQ_Mode;
-    u8      Disable_VGA;
-    u8      Differential_Enable;
-    u8      Auto_Mode;
-    u8      VGA_Status;
-    u8      RC4State;
-    u8      Advance_Table;
-} TRANSFER_HEADER, *PTRANSFER_HEADER;
-
-static struct fbinfo
-{
+struct fbinfo {
 	u16		x;
 	u16		y;
 	u8	color_mode;	//0:NON, 1:EGA, 2:VGA, 3:15bpp, 4:16bpp, 5:32bpp
@@ -140,7 +596,7 @@ static struct fbinfo
 };
 
 //For Socket Transfer head formate ..
-static struct compress_header {
+struct compress_header {
 	u32 data_len;
 	u32 block_changed;
 	u16	user_width;
@@ -157,40 +613,65 @@ static struct compress_header {
 	u8	Visual_Lossless;
 };
 
-static struct ast_video_data {
+struct aspeed_video_config {
+	u8		version;	
+	u32		dram_base;
+};
+
+struct aspeed_video_mem {
+	dma_addr_t	dma;
+	void *virt;
+};
+
+struct ast_video_data {
 	struct device		*misc_dev;
 	void __iomem		*reg_base;			/* virtual */
-	int 	irq;				//Video IRQ number 
-//	compress_header	
+	struct regmap		*scu;
+	struct regmap		*gfx;
+	int 	irq;				//Video IRQ number
+	struct aspeed_video_config	*config;
+	struct reset_control *reset;
+	struct clk 			*vclk;
+	struct clk 			*eclk;
+//	compress_header
 	struct compress_header			compress_mode;
-        phys_addr_t             *stream_phy;            /* phy */
-        u32                             *stream_virt;           /* virt */
-        phys_addr_t             *buff0_phy;             /* phy */
-        u32                             *buff0_virt;            /* virt */
-        phys_addr_t             *buff1_phy;             /* phy */
-        u32                             *buff1_virt;            /* virt */
-        phys_addr_t             *bcd_phy;               /* phy */
-        u32                             *bcd_virt;              /* virt */
-        phys_addr_t             *jpeg_phy;              /* phy */
-        u32                             *jpeg_virt;             /* virt */
-        phys_addr_t             *jpeg_buf0_phy;              /* phy */
-        u32                             *jpeg_buf0_virt;             /* virt */
-        phys_addr_t             *jpeg_tbl_phy;          /* phy */
-        u32                             *jpeg_tbl_virt;         /* virt */
-
-	//config 
-	video_source	input_source;	
+
+	struct aspeed_video_mem		video_mem;
+
+	phys_addr_t             *stream_phy;            /* phy */
+	u32                             *stream_virt;           /* virt */
+	phys_addr_t             *buff0_phy;             /* phy */
+	u32                             *buff0_virt;            /* virt */
+	phys_addr_t             *buff1_phy;             /* phy */
+	u32                             *buff1_virt;            /* virt */
+	phys_addr_t             *bcd_phy;               /* phy */
+	u32                             *bcd_virt;              /* virt */
+	phys_addr_t             *jpeg_phy;              /* phy */
+	u32                             *jpeg_virt;             /* virt */
+	phys_addr_t             *jpeg_buf0_phy;              /* phy */
+	u32                             *jpeg_buf0_virt;             /* virt */
+	phys_addr_t             *jpeg_tbl_phy;          /* phy */
+	u32                             *jpeg_tbl_virt;         /* virt */
+
+	//config
+	video_source	input_source;
 	u8	rc4_enable;
 	u8 EncodeKeys[256];
 	u8	scaling;
-		
-//JPEG 
-	u32		video_mem_size;			/* phy size*/		
-	
-	wait_queue_head_t 	queue;	
+
+//JPEG
+	u32		video_mem_size;			/* phy size*/
+	u32		video_jpeg_offset;			/* assigned jpeg memory size*/
+	u8 mode_change;
+	struct completion	mode_detect_complete;
+	struct completion	automode_complete;
+	struct completion	capture_complete;
+	struct completion	compression_complete;
+
+	wait_queue_head_t 	queue;
 
 	u32 flag;
-	wait_queue_head_t 	video_wq;	
+	wait_queue_head_t 	video_wq;
 
 	u32 thread_flag;
 	struct task_struct 		*thread_task;
@@ -199,51 +680,66 @@ static struct ast_video_data {
 
 	struct fbinfo					src_fbinfo;
 	struct fbinfo					dest_fbinfo;
-	struct completion				complete;	
+	struct completion				complete;
 	u32		sts;
 	u8		direct_mode;
 	u8		stage;
-	struct ast_video_plat_data		*plat_data;		
 	u32 	bandwidth;
-	struct mutex lock;	
+	struct mutex lock;
 
-        bool is_open;
-
-	
-        spinlock_t      video_state_lock;               /* Serializing lock */
-	struct fasync_struct *async_queue;		
-	
+	bool is_open;
 };
 
 //  RC4 structure
-struct rc4_state
-{
-    int x;
-    int y;
-    int m[256];
+struct rc4_state {
+	int x;
+	int y;
+	int m[256];
 };
- 
-DECLARE_WAIT_QUEUE_HEAD (my_queue);
 
+extern u32 ast_scu_get_vga_memsize(void);
+/***********************************************************************/
+#define AST_SCU_MISC1_CTRL			0x2C		/*	Misc. Control register */
+#define SCU_MISC_VGA_CRT_DIS		BIT(6)
+
+static void ast_scu_set_vga_display(struct ast_video_data *ast_video, u8 enable)
+{
+	if(enable)
+		regmap_update_bits(ast_video->scu, AST_SCU_MISC1_CTRL, SCU_MISC_VGA_CRT_DIS, 0);
+	else
+		regmap_update_bits(ast_video->scu, AST_SCU_MISC1_CTRL, SCU_MISC_VGA_CRT_DIS, SCU_MISC_VGA_CRT_DIS);
+}
+
+static int ast_scu_get_vga_display(struct ast_video_data *ast_video)
+{
+	u32 val;
+	regmap_read(ast_video->scu, AST_SCU_MISC1_CTRL, &val);
+
+	if(val & SCU_MISC_VGA_CRT_DIS)
+		return 0;
+	else
+		return 1;
+}
+
+/***********************************************************************/
 
-int  Mode_Changed = 0, Capture_Ready = 0, Compression_Ready = 0, Mode_Changed_Flag = 0;
 
 static inline void
 ast_video_write(struct ast_video_data *ast_video, u32 val, u32 reg)
 {
 //	VIDEO_DBG("write offset: %x, val: %x \n",reg,val);
 #ifdef CONFIG_AST_VIDEO_LOCK
-	//unlock 
+	//unlock
 	writel(VIDEO_PROTECT_UNLOCK, ast_video->reg_base);
 	writel(val, ast_video->reg_base + reg);
 	//lock
-	writel(0xaa,ast_video->reg_base);	
+	writel(0xaa, ast_video->reg_base);
 #else
-	//Video is lock after reset, need always unlock 
-	//unlock 
+	//Video is lock after reset, need always unlock
+	//unlock
 	writel(VIDEO_PROTECT_UNLOCK, ast_video->reg_base);
 	writel(val, ast_video->reg_base + reg);
-#endif	
+#endif
 }
 
 static inline u32
@@ -257,11 +753,11 @@ ast_video_read(struct ast_video_data *ast_video, u32 reg)
 /************************************************ JPEG ***************************************************************************************/
 void ast_init_jpeg_table(struct ast_video_data *ast_video)
 {
-	int i=0;
-	int base=0;
+	int i = 0;
+	int base = 0;
 	//JPEG header default value:
-	for(i = 0; i<12; i++) {
-		base = (1024*i);
+	for (i = 0; i < 12; i++) {
+		base = (256 * i);
 		ast_video->jpeg_tbl_virt[base + 0] = 0xE0FFD8FF;
 		ast_video->jpeg_tbl_virt[base + 1] = 0x464A1000;
 		ast_video->jpeg_tbl_virt[base + 2] = 0x01004649;
@@ -389,7 +885,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 		ast_video->jpeg_tbl_virt[base + 159] = 0x003F0011;
 
 		//Table 0
-		if (i==0) {
+		if (i == 0) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x0D140043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x0C0F110F;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x11101114;
@@ -426,7 +922,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFFB9B9B9;
 		}
 		//Table 1
-		if (i==1) {
+		if (i == 1) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x0C110043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x0A0D0F0D;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x0F0E0F11;
@@ -463,7 +959,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFFA0A0A0;
 		}
 		//Table 2
-		if (i==2) {
+		if (i == 2) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x090E0043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x090A0C0A;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x0C0B0C0E;
@@ -500,7 +996,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFF858585;
 		}
 		//Table 3
-		if (i==3) {
+		if (i == 3) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x070B0043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x07080A08;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x0A090A0B;
@@ -537,7 +1033,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFF6C6C6C;
 		}
 		//Table 4
-		if (i==4) {
+		if (i == 4) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x06090043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x05060706;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x07070709;
@@ -574,7 +1070,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFF505050;
 		}
 		//Table 5
-		if (i==5) {
+		if (i == 5) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x04060043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x03040504;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x05040506;
@@ -611,7 +1107,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFF373737;
 		}
 		//Table 6
-		if (i==6) {
+		if (i == 6) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x02030043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x01020202;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x02020203;
@@ -648,7 +1144,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFF1B1B1B;
 		}
 		//Table 7
-		if (i==7) {
+		if (i == 7) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x01020043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x01010101;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x01010102;
@@ -685,7 +1181,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFF121212;
 		}
 		//Table 8
-		if (i==8) {
+		if (i == 8) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x01020043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x01010101;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x01010102;
@@ -722,7 +1218,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFF0F0F0F;
 		}
 		//Table 9
-		if (i==9) {
+		if (i == 9) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x01010043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x01010101;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x01010101;
@@ -759,7 +1255,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFF0C0C0C;
 		}
 		//Table 10
-		if (i==10) {
+		if (i == 10) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x01010043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x01010101;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x01010101;
@@ -796,7 +1292,7 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 			ast_video->jpeg_tbl_virt[base + 43] = 0xFF090909;
 		}
 		//Table 11
-		if (i==11) {
+		if (i == 11) {
 			ast_video->jpeg_tbl_virt[base + 10] = 0x01010043;
 			ast_video->jpeg_tbl_virt[base + 11] = 0x01010101;
 			ast_video->jpeg_tbl_virt[base + 12] = 0x01010101;
@@ -837,18 +1333,27 @@ void ast_init_jpeg_table(struct ast_video_data *ast_video)
 
 }
 
+static u32 get_vga_mem_base(void)
+{
+	u32 vga_mem_size, mem_size;
+	mem_size = ast_sdmc_get_mem_size();
+	vga_mem_size = ast_scu_get_vga_memsize();
+//	printk("VGA Info : MEM Size %dMB, VGA Mem Size %dMB \n",mem_size/1024/1024, vga_mem_size/1024/1024);
+	return (mem_size - vga_mem_size);
+}
+
 static void ast_video_encryption_key_setup(struct ast_video_data *ast_video)
 {
 	int i, j, k, a, StringLength;
 	struct rc4_state  s;
-	u8 expkey[256];	
+	u8 expkey[256];
 	u32     temp;
 
 	//key expansion
 	StringLength = strlen(ast_video->EncodeKeys);
 //	printk("key %s , len = %d \n",ast_video->EncodeKeys, StringLength);
 	for (i = 0; i < 256; i++) {
-	    expkey[i] = ast_video->EncodeKeys[i % StringLength];
+		expkey[i] = ast_video->EncodeKeys[i % StringLength];
 //		printk(" %x ", expkey[i]);
 	}
 //	printk("\n");
@@ -863,82 +1368,14 @@ static void ast_video_encryption_key_setup(struct ast_video_data *ast_video)
 	j = k = 0;
 	for (i = 0; i < 256; i++) {
 		a = s.m[i];
-		j = (unsigned char) (j + a + expkey[k]);
-		s.m[i] = s.m[j]; 
+		j = (unsigned char)(j + a + expkey[k]);
+		s.m[i] = s.m[j];
 		s.m[j] = a;
 		k++;
 	}
 	for (i = 0; i < 64; i++) {
 		temp = s.m[i * 4] + ((s.m[i * 4 + 1]) << 8) + ((s.m[i * 4 + 2]) << 16) + ((s.m[i * 4 + 3]) << 24);
-		ast_video_write(ast_video, temp, AST_VIDEO_ENCRYPT_SRAM + i*4);
-	}
-
-}
-
-void ast_get_vga_scratch_info(struct ast_video_data *ast_video)
-{
-	u32 i, Mode_Bandwidth, RefreshRateIndex;
-	u32 VGA_Scratch_350, VGA_Scratch_34C;	
-	u8 RefreshRate;
-
-	VIDEO_DBG("Get VGA SCRATCH INFO ...\n");
-	VGA_Scratch_350 = ast_video_read(ast_video, AST_VIDEO_SCRATCH_350);
-	//Check VGA Driver supports to write display information in scratch register
-	if (SCRATCH_VGA_GET_MODE_HEADER(VGA_Scratch_350) == 0xA8) { 
-		//VGA's Color Depth is 0 when real color depth is less than 8
-		ast_video->src_fbinfo.color_mode = SCRATCH_VGA_GET_NEW_COLOR_MODE(VGA_Scratch_350); 
-		ast_video->src_fbinfo.PixelClock = SCRATCH_VGA_GET_NEW_PIXEL_CLK(VGA_Scratch_350);
-		VIDEO_DBG("New Mode Information : Color depth %x, Pixel clk %x \n", ast_video->src_fbinfo.color_mode, ast_video->src_fbinfo.PixelClock);
-		//Check Bandwidth
-		if (ast_video->src_fbinfo.color_mode == 0) {
-			printk("Color Depth is not 16bpp or higher \n");
-			printk("disable direct mode \n");
-			//ast_video->direct_mode = 0;
-		} else {
-			//Video uses 32bits
-			Mode_Bandwidth = (ast_video->src_fbinfo.PixelClock * (ast_video->src_fbinfo.color_mode + 32)) / 8; 
-			printk("Mode_Bandwidth = %d\n", Mode_Bandwidth);
-			if (ast_video->bandwidth < Mode_Bandwidth) {
-				printk("Band Width is not enough change to direct mode\n");
-				//ast_video->direct_mode = 1;
-			} else {
-				printk("Band Width is enough\n");
-				//ast_video->direct_mode = 0;
-			}
-		}
-		
-	} else {
-		//Judge if bandwidth is not enough then enable direct mode in internal VGA
-		VGA_Scratch_34C = ast_video_read(ast_video, AST_VIDEO_SCRATCH_34C);
-		ast_video->src_fbinfo.color_mode = SCRATCH_VGA_GET_COLOR_MODE(VGA_Scratch_34C);
-		RefreshRate = SCRATCH_VGA_GET_REFLASH_RATE(VGA_Scratch_34C);
-		VIDEO_DBG("Old Mode Information : color depth %x, reflash rate %x \n", ast_video->src_fbinfo.color_mode, RefreshRate);
-		if (ast_video->src_fbinfo.color_mode >= VGA_15BPP_MODE) { //15bpp or higher
-			for (i = 0; i < (sizeof(Internal_Mode) / sizeof(INTERNAL_MODE)); i++) { 
-				if ((ast_video->src_fbinfo.x == Internal_Mode[i].HorizontalActive) && 
-					(ast_video->src_fbinfo.y == Internal_Mode[i].VerticalActive) && 
-					(RefreshRateIndex == Internal_Mode[i].RefreshRateIndex)) {
-
-					ast_video->src_fbinfo.PixelClock = Internal_Mode[i].PixelClock;
-					printk("Mode_PixelClock = %d\n", ast_video->src_fbinfo.PixelClock);
-				}
-			}
-			//Calculate bandwidth required for this mode
-			//Video requires pixelclock * 3, VGA requires pixelclock * bpp / 8
-			Mode_Bandwidth = ast_video->src_fbinfo.PixelClock * (4 + 2 * (ast_video->src_fbinfo.color_mode - 2));
-			printk("Mode_Bandwidth = %d\n", Mode_Bandwidth);
-			if (ast_video->bandwidth < Mode_Bandwidth) {
-				printk("Band Width is not enough\n");
-				//ast_video->direct_mode = 1;
-			}
-			else {
-				printk("Band Width is enough\n");
-				//ast_video->direct_mode = 0;
-			}
-		} else {
-			printk("!!!! Color Depth is not 16bpp or higher\n");
-			//ast_video->direct_mode = 0;
-		}
+		ast_video_write(ast_video, temp, AST_VIDEO_ENCRYPT_SRAM + i * 4);
 	}
 
 }
@@ -947,11 +1384,11 @@ static u8 ast_get_vga_signal(struct ast_video_data *ast_video)
 {
 	u32 VR34C, VR350, VR35C;
 	u8	color_mode;
-	
+
 	VR35C = ast_video_read(ast_video, AST_VIDEO_SCRATCH_35C);
 	VR35C &= 0xff000000;
 
-	if(VR35C & (SCRATCH_VGA_PWR_STS_HSYNC | SCRATCH_VGA_PWR_STS_VSYNC)) {
+	if (VR35C & (SCRATCH_VGA_PWR_STS_HSYNC | SCRATCH_VGA_PWR_STS_VSYNC)) {
 		VIDEO_DBG("No VGA Signal : PWR STS %x \n", VR35C);
 		return VGA_NO_SIGNAL;
 	} else if (VR35C == SCRATCH_VGA_MASK_REG) {
@@ -959,129 +1396,55 @@ static u8 ast_get_vga_signal(struct ast_video_data *ast_video)
 		return VGA_NO_SIGNAL;
 	} else if (VR35C & SCRATCH_VGA_SCREEN_OFF) {
 		VIDEO_DBG("No VGA Signal : Screen off %x \n", VR35C);
-		return VGA_NO_SIGNAL;		
-	} else if (!(VR35C & (SCRATCH_VGA_ATTRIBTE_INDEX_BIT5 | SCRATCH_VGA_MASK_REG | SCRATCH_VGA_CRT_RST | SCRATCH_VGA_RESET | SCRATCH_VGA_ENABLE ))) {
+		return VGA_NO_SIGNAL;
+	} else if (!(VR35C & (SCRATCH_VGA_ATTRIBTE_INDEX_BIT5 | SCRATCH_VGA_MASK_REG | SCRATCH_VGA_CRT_RST | SCRATCH_VGA_RESET | SCRATCH_VGA_ENABLE))) {
 		VIDEO_DBG("NO VGA Signal : unknow %x \n", VR35C);
 		return VGA_NO_SIGNAL;
 	} else {
 		VIDEO_DBG("VGA Signal VR35C %x \n", VR35C);
 		VR350 = ast_video_read(ast_video, AST_VIDEO_SCRATCH_350);
-		if(SCRATCH_VGA_GET_MODE_HEADER(VR350) == 0xA8) {
+		if (SCRATCH_VGA_GET_MODE_HEADER(VR350) == 0xA8) {
 			color_mode = SCRATCH_VGA_GET_NEW_COLOR_MODE(VR350);
 		} else {
-			VR34C = ast_video_read(ast_video, AST_VIDEO_SCRATCH_34C);	
-			if(SCRATCH_VGA_GET_COLOR_MODE(VR34C) >= VGA_15BPP_MODE) 
+			VR34C = ast_video_read(ast_video, AST_VIDEO_SCRATCH_34C);
+			if (SCRATCH_VGA_GET_COLOR_MODE(VR34C) >= VGA_15BPP_MODE)
 				color_mode = SCRATCH_VGA_GET_COLOR_MODE(VR34C);
 			else
 				color_mode = SCRATCH_VGA_GET_COLOR_MODE(VR34C);
 		}
-		if(color_mode == 0) {
+		if (color_mode == 0) {
 			VIDEO_DBG("EGA Mode \n");
 			ast_video->src_fbinfo.color_mode = EGA_MODE;
 			return EGA_MODE;
 		} else if (color_mode == 1) {
 			VIDEO_DBG("VGA Mode \n");
-			ast_video->src_fbinfo.color_mode = VGA_MODE;			
+			ast_video->src_fbinfo.color_mode = VGA_MODE;
 			return VGA_MODE;
 		} else if (color_mode == 2) {
 			VIDEO_DBG("15BPP Mode \n");
-			ast_video->src_fbinfo.color_mode = VGA_15BPP_MODE;			
+			ast_video->src_fbinfo.color_mode = VGA_15BPP_MODE;
 			return VGA_15BPP_MODE;
 		} else if (color_mode == 3) {
 			VIDEO_DBG("16BPP Mode \n");
-			ast_video->src_fbinfo.color_mode = VGA_16BPP_MODE;						
+			ast_video->src_fbinfo.color_mode = VGA_16BPP_MODE;
 			return VGA_16BPP_MODE;
 		} else if (color_mode == 4) {
 			VIDEO_DBG("32BPP Mode \n");
-			ast_video->src_fbinfo.color_mode = VGA_32BPP_MODE;						
+			ast_video->src_fbinfo.color_mode = VGA_32BPP_MODE;
 			return VGA_32BPP_MODE;
 		} else {
 			printk("TODO ... unknow ..\n");
-			ast_video->src_fbinfo.color_mode = VGA_MODE;						
+			ast_video->src_fbinfo.color_mode = VGA_MODE;
 			return VGA_MODE;
 		}
-	
-	}		
-}
-
-static void ast_video_scaling(struct ast_video_data *ast_video, u8 enable)
-{
-	u32 scan_line, v_factor, h_factor;
-	u32 ctrl = ast_video_read(ast_video, AST_VIDEO_CTRL);
-	if(enable) {
-		VIDEO_DBG("Scaling Enable\n");
-		//Calculate scaling factor D / S = 4096 / Factor	======> Factor = (S / D) * 4096
-		v_factor = ((ast_video->src_fbinfo.y - 1) * 4096) / (ast_video->src_fbinfo.y - 1);
-		if (v_factor < 4096)
-			v_factor = 4096;
-		if ((v_factor * (ast_video->src_fbinfo.y - 1)) != (ast_video->src_fbinfo.y - 1) * 4096)
-			v_factor += 1;
-
-		//Calculate scaling factor D / S = 4096 / Factor  ======> Factor = (S / D) * 4096
-		h_factor = ((ast_video->src_fbinfo.x - 1) * 4096) / (ast_video->src_fbinfo.x - 1);
-		if (h_factor < 4096)
-		    h_factor = 4096;
-		if ((h_factor * (ast_video->src_fbinfo.x - 1)) != (ast_video->src_fbinfo.x - 1) * 4096) 
-		    h_factor += 1;
-
-		//Down-Scaling
-		ctrl |= VIDEO_CTRL_DWN_SCALING(DWN_V2);
-		if(ast_video->src_fbinfo.x <= ast_video->dest_fbinfo.x) {
-			ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING0);
-			ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING1);
-			ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING2);
-			ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING3);
-		} else {
-			ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING0);
-			ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING1);
-			ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING2);
-			ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING3);
-		}
-	} else {// 1:1
-		VIDEO_DBG("Scaling Disable \n");
-		ast_video->dest_fbinfo.x = ast_video->src_fbinfo.x;
-		ast_video->dest_fbinfo.y = ast_video->src_fbinfo.y;
-		ctrl &= ~VIDEO_CTRL_DWN_SCALING_MASK;
-		v_factor = 4096;
-		h_factor = 4096;
-		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING0);
-		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING1);
-		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING2);
-		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING3);
-	}
-	ast_video_write(ast_video, ctrl, AST_VIDEO_CTRL);
-
-	VIDEO_DBG("Scaling factor : v : %d , h : %d \n",v_factor, h_factor);
-	ast_video_write(ast_video, VIDEO_V_SCAL_FACTOR(v_factor) | VIDEO_H_SCAL_FACTOR(h_factor), AST_VIDEO_SCAL_FACTOR);
-
-	//capture x y 
-	ast_video_write(ast_video, VIDEO_CAPTURE_H(ast_video->src_fbinfo.x) |
-					VIDEO_CAPTURE_V(ast_video->src_fbinfo.y)
-					, AST_VIDEO_CAPTURE_WIN);
 
-	//compression x,y
-	ast_video_write(ast_video, VIDEO_COMPRESS_H(ast_video->dest_fbinfo.x) |
-					VIDEO_COMPRESS_V(ast_video->dest_fbinfo.y)
-					, AST_VIDEO_COMPRESS_WIN);
-
-	// ??? why ??
-	if((ast_video->src_fbinfo.x % 8) == 0)
-		ast_video_write(ast_video, ast_video->src_fbinfo.x * 4
-						, AST_VIDEO_SOURCE_SCAN_LINE);
-	else {
-		scan_line = ast_video->src_fbinfo.x;
-		scan_line = scan_line + 16 - (scan_line % 16);
-		scan_line = scan_line * 4;
-		ast_video_write(ast_video, scan_line
-						, AST_VIDEO_SOURCE_SCAN_LINE);
 	}
-	
 }
 
 static u8 ast_video_mode_detect_analog(struct ast_video_data *ast_video)
 {
 	u32 ctrl;
-	
+
 	//Check polarity (video engine prefers negative signal) bit 0, 1 is 0
 	ctrl = VIDEO_FROM_EXT_SOURCE;
 	ctrl &= ~VIDEO_DIRT_FATCH;
@@ -1091,18 +1454,18 @@ static u8 ast_video_mode_detect_analog(struct ast_video_data *ast_video)
 #endif
 
 	//	2nd mode detection
-	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & 
+	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) &
 					~(VIDEO_DETECT_TRIGGER |
-					VIDEO_COMPRESS_TRIGGER |
-					VIDEO_AUTO_COMPRESS |
-					VIDEO_INSERT_FULL_COMPRESS)
-					,AST_VIDEO_SEQ_CTRL);
+					  VIDEO_COMPRESS_TRIGGER |
+					  VIDEO_AUTO_COMPRESS |
+					  VIDEO_INSERT_FULL_COMPRESS)
+					, AST_VIDEO_SEQ_CTRL);
 
 	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) |
-						VIDEO_DETECT_TRIGGER 
-						,AST_VIDEO_SEQ_CTRL);	
+					VIDEO_DETECT_TRIGGER
+					, AST_VIDEO_SEQ_CTRL);
 	//wait for detect ready...
-	while (!ast_video_read(ast_video, AST_VIDEO_INT_STS) & VIDEO_MODE_DETECT_RDY);
+	while (!(ast_video_read(ast_video, AST_VIDEO_INT_STS) & VIDEO_MODE_DETECT_RDY));
 
 	ast_video_write(ast_video, VIDEO_MODE_DETECT_RDY, AST_VIDEO_INT_STS);
 
@@ -1112,53 +1475,53 @@ static u8 ast_video_mode_detect_analog(struct ast_video_data *ast_video)
 
 static u8 ast_video_mode_detect_digital(struct ast_video_data *ast_video)
 {
-	//bit 12, 13 must be 0 , 
+	//bit 12, 13 must be 0 ,
 	//Check polarity (video engine prefers negative signal) bit 0, 1 is 0
-	//detect vga signal 
-	
+	//detect vga signal
+
 	/* Bruce120907. According to HJ:
 	** For analog video source, the HSync and VSync may not always sync together. So, VE may
 	** not be able to count line count correctly. And it causes lost of first horizontal line.
 	** Digital interface MUST NOT set this value.
 	*/
-	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_MODE_DET1) & 
-				~VIDEO_DET_HSYNC_DELAY_MASK) |
-				VIDEO_DET_LONG_H_STABLE_EN
-				, AST_VIDEO_MODE_DET1);	
-
-	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) & 
-				~(VIDEO_DUAL_EDGE_MODE | 
-				VIDEO_18BIT_SINGLE_EDGE | 
-				VIDEO_DVO_INPUT_DELAY_MASK | 
-				VIDEO_SO_VSYNC_POLARITY | 
-				VIDEO_SO_HSYNC_POLARITY) 
-				, AST_VIDEO_PASS_CTRL);	
+	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_MODE_DET1) &
+								~VIDEO_DET_HSYNC_DELAY_MASK) |
+					VIDEO_DET_LONG_H_STABLE_EN
+					, AST_VIDEO_MODE_DET1);
+
+	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) &
+					~(VIDEO_DUAL_EDGE_MODE |
+					  VIDEO_18BIT_SINGLE_EDGE |
+					  VIDEO_DVO_INPUT_DELAY_MASK |
+					  VIDEO_SO_VSYNC_POLARITY |
+					  VIDEO_SO_HSYNC_POLARITY)
+					, AST_VIDEO_PASS_CTRL);
 
 	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_MODE_DETECT) & 0xffff) |
 					VIDEO_MODE_HOR_TOLER(6) |
 					VIDEO_MODE_VER_TOLER(6) |
 					VIDEO_MODE_HOR_STABLE(2) |
 					VIDEO_MODE_VER_STABLE(2)
-					, AST_VIDEO_MODE_DETECT);	
+					, AST_VIDEO_MODE_DETECT);
 
 	//	2nd mode detection
-	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & 
+	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) &
 					~(VIDEO_DETECT_TRIGGER |
-					VIDEO_COMPRESS_TRIGGER |
-					VIDEO_AUTO_COMPRESS |
-					VIDEO_INSERT_FULL_COMPRESS)
-					,AST_VIDEO_SEQ_CTRL);
+					  VIDEO_COMPRESS_TRIGGER |
+					  VIDEO_AUTO_COMPRESS |
+					  VIDEO_INSERT_FULL_COMPRESS)
+					, AST_VIDEO_SEQ_CTRL);
 
 	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) |
-						VIDEO_DETECT_TRIGGER 
-						,AST_VIDEO_SEQ_CTRL);	
+					VIDEO_DETECT_TRIGGER
+					, AST_VIDEO_SEQ_CTRL);
 	//wait for detect ready...
-	while (!ast_video_read(ast_video, AST_VIDEO_INT_STS) & VIDEO_MODE_DETECT_RDY);
+	while (!(ast_video_read(ast_video, AST_VIDEO_INT_STS) & VIDEO_MODE_DETECT_RDY));
 
 	ast_video_write(ast_video, VIDEO_MODE_DETECT_RDY, AST_VIDEO_INT_STS);
 
 	//Get External digital/analog input signal type
-	if(ast_video_read(ast_video, AST_VIDEO_MODE_DET_STS) & VIDEO_DET_FROM_ADC)
+	if (ast_video_read(ast_video, AST_VIDEO_MODE_DET_STS) & VIDEO_DET_FROM_ADC)
 		printk("Detect Input signal is ADC \n");
 	else
 		printk("Detect Input signal is Digital \n");
@@ -1166,379 +1529,827 @@ static u8 ast_video_mode_detect_digital(struct ast_video_data *ast_video)
 	return 0;
 }
 
-static void ast_video_set_compress(struct ast_video_data *ast_video)
-{
-	u32 compress_mode = ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL);
-
-    if (ast_video->compress_mode.VQMode == 1)
-		compress_mode |= VIDEO_4COLOR_VQ_ENCODE;
-    else
-        compress_mode &= ~VIDEO_4COLOR_VQ_ENCODE;
-
-
-    switch (ast_video->compress_mode.mode) {
-        case 0:
-			compress_mode |= VIDEO_DCT_ONLY_ENCODE;
-    	    break;
-        case 1:
-            compress_mode &= ~(VIDEO_4COLOR_VQ_ENCODE |VIDEO_DCT_ONLY_ENCODE);
-    	    break;
-    	case 2:
-			compress_mode |= VIDEO_4COLOR_VQ_ENCODE;
-            break;
-        case 3: //No one ....
-//			compress_mode |= VIDEO_DCT_ONLY_ENCODE | ;
-			printk("ERROR .....\n");
-            break;
-        default:
-			printk("ERROR \n");
-            compress_mode |= VIDEO_DCT_ONLY_ENCODE;
-            break;
-    }
-	compress_mode |= VIDEO_HQ_DCT_LUM(ast_video->compress_mode.AdvanceTableSelector);	
-	compress_mode |= VIDEO_HQ_DCT_CHROM((ast_video->compress_mode.AdvanceTableSelector + 16));
-    compress_mode |= VIDEO_DCT_LUM(ast_video->compress_mode.Y_JPEGTableSelector);
-    compress_mode |= VIDEO_DCT_CHROM(ast_video->compress_mode.UV_JPEGTableSelector);
-    if (ast_video->compress_mode.Visual_Lossless == 1) 
-		compress_mode |= VIDEO_HQ_ENABLE;
-    else 
-		compress_mode &= ~VIDEO_HQ_ENABLE;
-
-	ast_video_write(ast_video, compress_mode, AST_VIDEO_COMPRESS_CTRL);
-}
-
-static void ast_video_set_direct_fatch(struct ast_video_data *ast_video, u8 direct_mode)
+static void ast_video_set_eng_config(struct ast_video_data *ast_video, struct ast_video_config *video_config)
 {
-	u32 vga_base;
-	u32 H_Start, H_End, V_Start, V_End;
-	u32 ctrl = ast_video_read(ast_video, AST_VIDEO_PASS_CTRL);
+	int i, base = 0;
+	u32 ctrl = 0;
+	u32 compress_ctrl = 0x00080000;
 
-	H_Start = VIDEO_GET_HSYNC_LEFT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
-	H_End = VIDEO_GET_HSYNC_RIGHT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
-	
-	V_Start = VIDEO_GET_VSYNC_TOP(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));	
-	V_End = VIDEO_GET_VSYNC_BOTTOM(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS)); 	
+	VIDEO_DBG("\n");
 
-	VIDEO_DBG("Get H_Start = %d, H_End = %d, V_Start = %d, V_End = %d\n", H_Start, H_End, V_Start, V_End);
+	switch (video_config->engine) {
+	case 0:
+		ctrl = ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL);
+		break;
+	case 1:
+		ctrl = ast_video_read(ast_video, AST_VM_SEQ_CTRL);
+		break;
+	}
 
-	ast_video->src_fbinfo.x = (H_End - H_Start) + 1;
-	ast_video->src_fbinfo.y = (V_End - V_Start) + 1;
-	VIDEO_DBG("source : x = %d, y = %d , color mode = %x \n", ast_video->src_fbinfo.x, ast_video->src_fbinfo.y,ast_video->src_fbinfo.color_mode);
 
-	VIDEO_DBG("mode : %d\n",direct_mode);
+	if (video_config->AutoMode) {
+		ctrl |= VIDEO_AUTO_COMPRESS;
 
-	if(direct_mode) {
-		ctrl &= ~(VIDEO_16BPP_MODE_555 | VIDEO_16BPP_MODE | VIDEO_DVO_INPUT_DELAY_MASK);
-		
-		if(ast_video->src_fbinfo.color_mode == VGA_16BPP_MODE)
-			ctrl |= VIDEO_16BPP_MODE | VIDEO_DIRT_FATCH | VIDEO_AUTO_FATCH | VIDEO_DVO_INPUT_DELAY(0x4);
-		else {
-			ctrl |= VIDEO_DIRT_FATCH | VIDEO_AUTO_FATCH | VIDEO_DVO_INPUT_DELAY(0x4);
-		}
-		ast_video_write(ast_video, ctrl , AST_VIDEO_PASS_CTRL);
-		
-		vga_base = ast_video->plat_data->get_vga_base();
-		
-		VIDEO_DBG("vga base = %x \n",vga_base );
-		
-		ast_video_write(ast_video, vga_base, AST_VIDEO_DIRECT_BASE);	
-		
-		ast_video_write(ast_video, VIDEO_FETCH_TIMING(0) |
-						VIDEO_FETCH_LINE_OFFSET(ast_video->src_fbinfo.x * 4)
-						, AST_VIDEO_DIRECT_CTRL);		
-		
 	} else {
-		ctrl &=~(VIDEO_DIRT_FATCH | VIDEO_AUTO_FATCH);
-		ctrl |= VIDEO_INTERNAL_DE | VIDEO_16BPP_MODE | VIDEO_DVO_INPUT_DELAY(0x4);
-		ast_video_write(ast_video, ctrl, AST_VIDEO_PASS_CTRL); 
-
-		ast_video_write(ast_video, VIDEO_HSYNC_PIXEL_FIRST_SET(H_Start - 1) | 
-						VIDEO_HSYNC_PIXEL_LAST_SET(H_End), 
-						AST_VIDEO_TIMING_H);
-		ast_video_write(ast_video, VIDEO_VSYNC_PIXEL_FIRST_SET(V_Start) | 
-						VIDEO_VSYNC_PIXEL_LAST_SET(V_End + 1), 
-						AST_VIDEO_TIMING_V);
-	
+		ctrl &= ~VIDEO_AUTO_COMPRESS;
 	}
-}
-
-static void ast_video_mode_detect_trigger(struct ast_video_data *ast_video)
-{
-	VIDEO_DBG("ast_video_mode_detect_trigger \n");
 
-	if(!ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & VIDEO_CAPTURE_BUSY) {
-		printk("Capture Eng busy !! 0x04 : %x \n", ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL));
+	ast_video_write(ast_video, VIDEO_COMPRESS_COMPLETE | VIDEO_CAPTURE_COMPLETE | VIDEO_MODE_DETECT_WDT, AST_VIDEO_INT_EN);
 
+	if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+		if (video_config->compression_format)
+			ctrl |= G5_VIDEO_COMPRESS_JPEG_MODE;
+		else
+			ctrl &= ~G5_VIDEO_COMPRESS_JPEG_MODE;
+	} else {
+		if (video_config->compression_format)
+			ctrl |= VIDEO_COMPRESS_JPEG_MODE;
+		else
+			ctrl &= ~VIDEO_COMPRESS_JPEG_MODE;
 	}
-	
-	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & 
-						~(VIDEO_DETECT_TRIGGER | VIDEO_INPUT_MODE_CHG_WDT)
-						,AST_VIDEO_SEQ_CTRL);
-	udelay(1);
-	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) |
-						VIDEO_DETECT_TRIGGER 
-						,AST_VIDEO_SEQ_CTRL);			
+	ctrl &= ~VIDEO_COMPRESS_FORMAT_MASK;
 
-	while(!(ast_video_read(ast_video, AST_VIDEO_INT_STS) & VIDEO_MODE_DETECT_RDY));
-	printk("int sts = %x \n",ast_video_read(ast_video, AST_VIDEO_INT_STS));
+	if (video_config->YUV420_mode) {
+		ctrl |= VIDEO_COMPRESS_FORMAT(YUV420);
+	}
 
-	ast_video_write(ast_video, VIDEO_MODE_DETECT_RDY, AST_VIDEO_INT_STS);			
-	
-}
+	if (video_config->rc4_enable) {
+		compress_ctrl |= VIDEO_ENCRYP_ENABLE;
+	}
 
-static void ast_video_mode_detect_info(struct ast_video_data *ast_video)
+	switch (video_config->compression_mode) {
+	case 0:	//DCT only
+		compress_ctrl |= VIDEO_DCT_ONLY_ENCODE;
+		break;
+	case 1:	//DCT VQ mix 2-color
+		compress_ctrl &= ~(VIDEO_4COLOR_VQ_ENCODE | VIDEO_DCT_ONLY_ENCODE);
+		break;
+	case 2:	//DCT VQ mix 4-color
+		compress_ctrl |= VIDEO_4COLOR_VQ_ENCODE;
+		break;
+	default:
+		printk("error for compression mode~~~~\n");
+		break;
+	}
 
-{
-	u32 H_Start, H_End, V_Start, V_End;
+	if (video_config->Visual_Lossless) {
+		compress_ctrl |= VIDEO_HQ_ENABLE;
+		compress_ctrl |= VIDEO_HQ_DCT_LUM(video_config->AdvanceTableSelector);
+		compress_ctrl |= VIDEO_HQ_DCT_CHROM((video_config->AdvanceTableSelector + 16));
+	} else
+		compress_ctrl &= ~VIDEO_HQ_ENABLE;
+
+	switch (video_config->engine) {
+	case 0:
+		ast_video_write(ast_video, ctrl, AST_VIDEO_SEQ_CTRL);
+		ast_video_write(ast_video, compress_ctrl | VIDEO_DCT_LUM(video_config->Y_JPEGTableSelector) | VIDEO_DCT_CHROM(video_config->Y_JPEGTableSelector + 16), AST_VIDEO_COMPRESS_CTRL);
+		break;
+	case 1:
+		ast_video_write(ast_video, ctrl, AST_VM_SEQ_CTRL);
+		ast_video_write(ast_video, compress_ctrl | VIDEO_DCT_LUM(video_config->Y_JPEGTableSelector) | VIDEO_DCT_CHROM(video_config->Y_JPEGTableSelector + 16), AST_VM_COMPRESS_CTRL);
+		break;
+	}
 
-	H_Start = VIDEO_GET_HSYNC_LEFT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
-	H_End = VIDEO_GET_HSYNC_RIGHT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
-	
-	V_Start = VIDEO_GET_VSYNC_TOP(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));	
-	V_End = VIDEO_GET_VSYNC_BOTTOM(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS)); 	
+	if (video_config->compression_format == 1) {
+		for (i = 0; i < 12; i++) {
+			base = (1024 * i);
+			if (video_config->YUV420_mode)	//yuv420
+				ast_video->jpeg_tbl_virt[base + 46] = 0x00220103; //for YUV420 mode
+			else
+				ast_video->jpeg_tbl_virt[base + 46] = 0x00110103; //for YUV444 mode)
+		}
+	}
 
-	VIDEO_DBG("Get H_Start = %d, H_End = %d, V_Start = %d, V_End = %d\n", H_Start, H_End, V_Start, V_End);
 
-	ast_video->src_fbinfo.x = (H_End - H_Start) + 1;
-	ast_video->src_fbinfo.y = (V_End - V_Start) + 1;
-	VIDEO_DBG("source : x = %d, y = %d , color mode = %x \n", ast_video->src_fbinfo.x, ast_video->src_fbinfo.y,ast_video->src_fbinfo.color_mode);
 }
 
-static void ast_video_mode_detect(struct ast_video_data *ast_video)
+static void ast_video_set_0_scaling(struct ast_video_data *ast_video, struct ast_scaling *scaling)
 {
-	u32 ctrl;
-	int r;			
-	u8 color_mode;
-	int i;
-	u8 HPolarity_Positive = 0, HPolarity_Negative = 0, VPolarity_Positive = 0, VPolarity_Negative = 0;
-	u8 Horizontal_Polarity = 0, Vertical_Polarity = 0;
-	u32 sts;
-    u32 H_Temp = 0, V_Temp = 0;
-
-	VIDEO_DBG("\n");
+	u32 scan_line, v_factor, h_factor;
+	u32 ctrl = ast_video_read(ast_video, AST_VIDEO_CTRL);
+	//no scaling
+	ctrl &= ~VIDEO_CTRL_DWN_SCALING_MASK;
+
+	if (scaling->enable) {
+		if ((ast_video->src_fbinfo.x == scaling->x) && (ast_video->src_fbinfo.y == scaling->y)) {
+			ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING0);
+			ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING1);
+			ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING2);
+			ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING3);
+			//compression x,y
+			ast_video_write(ast_video, VIDEO_COMPRESS_H(ast_video->src_fbinfo.x) | VIDEO_COMPRESS_V(ast_video->src_fbinfo.y), AST_VIDEO_COMPRESS_WIN);
+			ast_video_write(ast_video, 0x10001000, AST_VIDEO_SCAL_FACTOR);
+		} else {
+			//Down-Scaling
+			VIDEO_DBG("Scaling Enable\n");
+			//Calculate scaling factor D / S = 4096 / Factor  ======> Factor = (S / D) * 4096
+			h_factor = ((ast_video->src_fbinfo.x - 1) * 4096) / (scaling->x - 1);
+			if (h_factor < 4096)
+				h_factor = 4096;
+			if ((h_factor * (scaling->x - 1)) != (ast_video->src_fbinfo.x - 1) * 4096)
+				h_factor += 1;
+
+			//Calculate scaling factor D / S = 4096 / Factor	======> Factor = (S / D) * 4096
+			v_factor = ((ast_video->src_fbinfo.y - 1) * 4096) / (scaling->y - 1);
+			if (v_factor < 4096)
+				v_factor = 4096;
+			if ((v_factor * (scaling->y - 1)) != (ast_video->src_fbinfo.y - 1) * 4096)
+				v_factor += 1;
+
+			if ((ast_video->config->version != 5) && (ast_video->config->version != 6))
+				ctrl |= VIDEO_CTRL_DWN_SCALING_ENABLE_LINE_BUFFER;
+
+			if (ast_video->src_fbinfo.x <= scaling->x * 2) {
+				ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING0);
+				ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING1);
+				ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING2);
+				ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING3);
+			} else {
+				ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING0);
+				ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING1);
+				ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING2);
+				ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING3);
+			}
+			//compression x,y
+			ast_video_write(ast_video, VIDEO_COMPRESS_H(scaling->x) | VIDEO_COMPRESS_V(scaling->y), AST_VIDEO_COMPRESS_WIN);
 
-//	ast_video->plat_data->ctrl_reset();
-	//set input signal  and Check polarity (video engine prefers negative signal)		
-	if(ast_video->input_source <= VIDEO_SOURCE_INT_CRT) {
-		ast_get_vga_scratch_info(ast_video);
-		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) &
-						~VIDEO_FROM_EXT_SOURCE) |
-						VIDEO_SO_VSYNC_POLARITY | VIDEO_SO_HSYNC_POLARITY,
-						AST_VIDEO_PASS_CTRL); 		
-	} else {
-		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) &
-						~(VIDEO_SO_VSYNC_POLARITY | VIDEO_SO_HSYNC_POLARITY)) |
-						VIDEO_FROM_EXT_SOURCE
-						,AST_VIDEO_PASS_CTRL); 				
-	}
-	
-	//1st mode detect
-	ast_video_mode_detect_trigger(ast_video);
+			VIDEO_DBG("Scaling factor : v : %d , h : %d \n", v_factor, h_factor);
+			ast_video_write(ast_video, VIDEO_V_SCAL_FACTOR(v_factor) | VIDEO_H_SCAL_FACTOR(h_factor), AST_VIDEO_SCAL_FACTOR);
+		}
+	} else {// 1:1
+		VIDEO_DBG("Scaling Disable \n");
+		v_factor = 4096;
+		h_factor = 4096;
+		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING0);
+		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING1);
+		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING2);
+		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING3);
+		//compression x,y
+		ast_video_write(ast_video, VIDEO_COMPRESS_H(ast_video->src_fbinfo.x) | VIDEO_COMPRESS_V(ast_video->src_fbinfo.y), AST_VIDEO_COMPRESS_WIN);
 
-	// 0 for negative, 1 for positive, hardware always use rising edge
-	for(i=0; i<10; i++) {
-		sts = ast_video_read(ast_video, AST_VIDEO_MODE_DET_STS);
-		sts = ast_video_read(ast_video, AST_VIDEO_MODE_DET_STS) & VIDEO_DET_VSYNC_POLAR;
-		if (sts == 0)
-			VPolarity_Negative++;
-		else
-			VPolarity_Positive++;
-	}
-	
-	if (VPolarity_Positive > VPolarity_Negative)
-		Vertical_Polarity = 1;
-	else
-		Vertical_Polarity = 0;
-	
-	
-	for(i=0; i<10; i++) {
-		sts = ast_video_read(ast_video, AST_VIDEO_MODE_DET_STS);
-		sts = ast_video_read(ast_video, AST_VIDEO_MODE_DET_STS) & VIDEO_DET_HSYNC_POLAR;
-		if (sts == 0)
-			HPolarity_Negative++;
-		else
-			HPolarity_Positive++;
+		ast_video_write(ast_video, 0x10001000, AST_VIDEO_SCAL_FACTOR);
 	}
-	
-	if (HPolarity_Positive > HPolarity_Negative)
-		Horizontal_Polarity = 1;
-	else
-		Horizontal_Polarity = 0;
-
-	VIDEO_DBG("Get polarity \n H_pos : %d, H_Neg : %d, H_pol : %d, \n V_pos : %d, V_Neg : %d, V_pol : %d \n", 
-				HPolarity_Positive, HPolarity_Negative, Horizontal_Polarity, 
-				VPolarity_Positive, VPolarity_Negative, Vertical_Polarity);
-
-	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) |
-					(Vertical_Polarity * VIDEO_SO_VSYNC_POLARITY) |
-					(Horizontal_Polarity * VIDEO_SO_HSYNC_POLARITY)
-					, AST_VIDEO_PASS_CTRL); 	
-
-	//2nd mode detect and get detect info
-	ast_video_mode_detect_trigger(ast_video);
+	ast_video_write(ast_video, ctrl, AST_VIDEO_CTRL);
 
-	if(ast_video->input_source == VIDEO_SOURCE_INT_VGA) {
-		color_mode = ast_get_vga_signal(ast_video);
-		if(color_mode) {
-			if(color_mode >= VGA_15BPP_MODE) {
-				VIDEO_DBG("Set Direct Mode \n");
-				ast_video->direct_mode = 1;
-				ast_video_set_direct_fatch(ast_video, 1);
-			} else {
-				VIDEO_DBG("Set Sync Mode \n");
-				ast_video->direct_mode = 0;
-				ast_video_set_direct_fatch(ast_video, 0);
-			}
-		}else {
-			VIDEO_DBG("NO VGA Signal ..... \n");
-		}
-		
-	} else {
-		//Get External digital/analog input signal type
-		if(ast_video_read(ast_video, AST_VIDEO_MODE_DET_STS) & VIDEO_DET_FROM_ADC) {
-			VIDEO_DBG("Detect Input signal : Analog ... TODO ...\n");
-			//....JudgeMode 
-			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) | 
-						VIDEO_INTERNAL_DE | VIDEO_EXT_ADC_ATTRIBUTE, 
-						AST_VIDEO_PASS_CTRL);			
+	//capture x y
+	if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+		//A1 issue fix
+		if (ast_video->src_fbinfo.x == 1680) {
+			ast_video_write(ast_video, VIDEO_CAPTURE_H(1728) | VIDEO_CAPTURE_V(ast_video->src_fbinfo.y), AST_VIDEO_CAPTURE_WIN);
 		} else {
-			VIDEO_DBG("Detect Input signal : Digital ... TODO ...\n");
-			//.... AutoPosition 
-			ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) & 
-						~(VIDEO_INTERNAL_DE | VIDEO_EXT_ADC_ATTRIBUTE)), 
-						AST_VIDEO_PASS_CTRL); 
-
+			ast_video_write(ast_video, VIDEO_CAPTURE_H(ast_video->src_fbinfo.x) |	VIDEO_CAPTURE_V(ast_video->src_fbinfo.y)	, AST_VIDEO_CAPTURE_WIN);
 		}
+	} else {
+		ast_video_write(ast_video, VIDEO_CAPTURE_H(ast_video->src_fbinfo.x) | 	VIDEO_CAPTURE_V(ast_video->src_fbinfo.y), AST_VIDEO_CAPTURE_WIN);
 	}
 
-#if 1
-	u8 det_err = 0;
-	u32 det_sts = ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS);
 
-	if(det_sts & VIDEO_NO_DISPLAY_CLOCK_DET) {
-		det_err = 1;
-		printk("VIDEO_NO_DISPLAY_CLOCK_DET \n");
-	}
-	
-	if(det_sts & VIDEO_NO_ACT_DISPLAY_DET) {
-		det_err = 1;	
-		printk("VIDEO_NO_ACT_DISPLAY_DET \n");
-	}
-	
-	if(det_sts & VIDEO_NO_HSYNC_DET) {
-		det_err = 1;
-		printk("VIDEO_NO_HSYNC_DET \n");
-	}
-	
-	if(det_sts & VIDEO_NO_VSYNC_DET) {
-		det_err = 1;		
-		printk("VIDEO_NO_VSYNC_DET \n");
+	if ((ast_video->src_fbinfo.x % 8) == 0)
+		ast_video_write(ast_video, ast_video->src_fbinfo.x * 4, AST_VIDEO_SOURCE_SCAN_LINE);
+	else {
+		scan_line = ast_video->src_fbinfo.x;
+		scan_line = scan_line + 16 - (scan_line % 16);
+		scan_line = scan_line * 4;
+		ast_video_write(ast_video, scan_line, AST_VIDEO_SOURCE_SCAN_LINE);
 	}
 
-	u32 sync_rdy = ast_video_read(ast_video, AST_VIDEO_MODE_DET_STS);
+}
+
+static void ast_video_set_1_scaling(struct ast_video_data *ast_video, struct ast_scaling *scaling)
+{
+	u32 v_factor, h_factor;
 
-	if(!sync_rdy & VIDEO_DET_HSYNC_RDY) {
-		det_err = 1;		
-		printk("VIDEO_DET_HSYNC_RDY NO \n");
+	if (scaling->enable) {
+		if ((ast_video->src_fbinfo.x == scaling->x) && (ast_video->src_fbinfo.y == scaling->y)) {
+			ast_video_write(ast_video, VIDEO_COMPRESS_H(ast_video->src_fbinfo.x) | VIDEO_COMPRESS_V(ast_video->src_fbinfo.y), AST_VM_COMPRESS_WIN);
+			ast_video_write(ast_video, 0x10001000, AST_VM_SCAL_FACTOR);
+		} else {
+			//Down-Scaling
+			VIDEO_DBG("Scaling Enable\n");
+			//Calculate scaling factor D / S = 4096 / Factor  ======> Factor = (S / D) * 4096
+			h_factor = ((ast_video->src_fbinfo.x - 1) * 4096) / (scaling->x - 1);
+			if (h_factor < 4096)
+				h_factor = 4096;
+			if ((h_factor * (scaling->x - 1)) != (ast_video->src_fbinfo.x - 1) * 4096)
+				h_factor += 1;
+
+			//Calculate scaling factor D / S = 4096 / Factor	======> Factor = (S / D) * 4096
+			v_factor = ((ast_video->src_fbinfo.y - 1) * 4096) / (scaling->y - 1);
+			if (v_factor < 4096)
+				v_factor = 4096;
+			if ((v_factor * (scaling->y - 1)) != (ast_video->src_fbinfo.y - 1) * 4096)
+				v_factor += 1;
+
+			//compression x,y
+			ast_video_write(ast_video, VIDEO_COMPRESS_H(scaling->x) | VIDEO_COMPRESS_V(scaling->y), AST_VM_COMPRESS_WIN);
+			ast_video_write(ast_video, VIDEO_V_SCAL_FACTOR(v_factor) | VIDEO_H_SCAL_FACTOR(h_factor), AST_VM_SCAL_FACTOR);
+		}
+	} else {// 1:1
+		VIDEO_DBG("Scaling Disable \n");
+		ast_video_write(ast_video, VIDEO_COMPRESS_H(ast_video->src_fbinfo.x) | VIDEO_COMPRESS_V(ast_video->src_fbinfo.y), AST_VM_COMPRESS_WIN);
+		ast_video_write(ast_video, 0x10001000, AST_VM_SCAL_FACTOR);
 	}
-	if(!sync_rdy & VIDEO_DET_VSYNC_RDY) {
-		det_err = 1;		
-		printk("VIDEO_DET_VSYNC_RDY NO \n");
+
+	//capture x y
+	if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+		if (ast_video->src_fbinfo.x == 1680) {
+			ast_video_write(ast_video, VIDEO_CAPTURE_H(1728) | VIDEO_CAPTURE_V(ast_video->src_fbinfo.y), AST_VM_CAPTURE_WIN);
+		} else {
+			ast_video_write(ast_video, VIDEO_CAPTURE_H(ast_video->src_fbinfo.x) | VIDEO_CAPTURE_V(ast_video->src_fbinfo.y), AST_VM_CAPTURE_WIN);
+		}
+	} else {
+		ast_video_write(ast_video, VIDEO_CAPTURE_H(ast_video->src_fbinfo.x) | VIDEO_CAPTURE_V(ast_video->src_fbinfo.y)	, AST_VM_CAPTURE_WIN);
 	}
 
-	if(det_err)
-		return det_err;
-	
-#endif
-	
-	//  Enable Watchdog detection
-	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_INPUT_MODE_CHG_WDT,
-						AST_VIDEO_SEQ_CTRL);
 
 }
 
-static irqreturn_t ast_video_handler(int this_irq, void *dev_id)
+static void ast_video_mode_detect_trigger(struct ast_video_data *ast_video)
 {
-	struct ast_video_data *ast_video = dev_id;
-	u32 sts = ast_video_read(ast_video, AST_VIDEO_INT_STS) & ast_video_read(ast_video, AST_VIDEO_INT_EN);
-	u32 buff0, buff1;
-	
-	VIDEO_DBG("ISR = %x : ",sts);
-	
-	if (sts & VIDEO_MODE_DETECT_WDT) {
-		VIDEO_DBG("VIDEO_MODE_DETECT_WDT \n");
-		ast_video_write(ast_video, VIDEO_MODE_DETECT_WDT, AST_VIDEO_INT_STS);
-//		ast_video->cur_state = VIDEO_MODECHANGE;
-		wake_up_process(ast_video->thread_task);
-	} 
+	VIDEO_DBG("\n");
 
-	if (sts & VIDEO_MODE_DETECT_RDY) {
-		VIDEO_DBG("VIDEO_MODE_DETECT_RDY !!\n");
-		ast_video_write(ast_video, VIDEO_MODE_DETECT_RDY, AST_VIDEO_INT_STS);
-//		ast_video->flag = VIDEO_MODE_DETECT_RDY;
-		wake_up_interruptible(&ast_video->video_wq);
-	}
+	if (!(ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & VIDEO_CAPTURE_BUSY)) {
+		printk("ERROR ~~ Capture Eng busy !! 0x04 : %x \n", ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL));
 
-	if (sts & VIDEO_CAPTURE_COMPLETE) {
-		VIDEO_DBG("VIDEO_CAPTURE_COMPLETE \n");
-		ast_video_write(ast_video, VIDEO_CAPTURE_COMPLETE, AST_VIDEO_INT_STS);
-//		ast_video->flag = VIDEO_CAPTURE_COMPLETE;		
-		wake_up_interruptible(&ast_video->video_wq);
 	}
 
-	if (sts & VIDEO_COMPRESS_COMPLETE) {
-		VIDEO_DBG("VIDEO_COMPRESS_COMPLETE \n");
-		ast_video_write(ast_video, VIDEO_COMPRESS_COMPLETE, AST_VIDEO_INT_STS);
-		ast_video->flag = VIDEO_COMPRESS_COMPLETE;
-		//swap		
-		buff0 = ast_video_read(ast_video, AST_VIDEO_SOURCE_BUFF0);
-		buff1 = ast_video_read(ast_video, AST_VIDEO_SOURCE_BUFF1);
-		ast_video_write(ast_video, buff1, AST_VIDEO_SOURCE_BUFF0);
-		ast_video_write(ast_video, buff0, AST_VIDEO_SOURCE_BUFF1);
-		wake_up_interruptible(&ast_video->video_wq);
+	init_completion(&ast_video->mode_detect_complete);
+
+	ast_video_write(ast_video, VIDEO_MODE_DETECT_RDY, AST_VIDEO_INT_EN);
+
+	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~(VIDEO_DETECT_TRIGGER | VIDEO_INPUT_MODE_CHG_WDT), AST_VIDEO_SEQ_CTRL);
+
+	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_DETECT_TRIGGER, AST_VIDEO_SEQ_CTRL);
+
+	wait_for_completion_interruptible(&ast_video->mode_detect_complete);
+
+	ast_video_write(ast_video, 0, AST_VIDEO_INT_EN);
+
+}
+
+static void ast_video_vga_mode_detect(struct ast_video_data *ast_video, struct ast_mode_detection *mode_detect)
+{
+	u32 H_Start, H_End, V_Start, V_End;
+	u32 H_Temp = 0, V_Temp = 0, RefreshRateIndex, ColorDepthIndex;
+	u32 VGA_Scratch_Register_350, VGA_Scratch_Register_354, VGA_Scratch_Register_34C, Color_Depth, Mode_Clock;
+	u8 Direct_Mode;
+
+	VIDEO_DBG("\n");
+
+	//set input signal  and Check polarity (video engine prefers negative signal)
+	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) &
+								~(VIDEO_DIRT_FATCH | VIDEO_EXT_ADC_ATTRIBUTE)) |
+					VIDEO_INTERNAL_DE |
+					VIDEO_SO_VSYNC_POLARITY | VIDEO_SO_HSYNC_POLARITY,
+					AST_VIDEO_PASS_CTRL);
+
+	ast_video_mode_detect_trigger(ast_video);
+
+	//Enable Watchdog detection
+	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_INPUT_MODE_CHG_WDT, AST_VIDEO_SEQ_CTRL);
+
+Redo:
+	//for store lock
+	ast_video_mode_detect_trigger(ast_video);
+
+	H_Start = VIDEO_GET_HSYNC_LEFT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
+	H_End = VIDEO_GET_HSYNC_RIGHT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
+
+	V_Start = VIDEO_GET_VSYNC_TOP(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));
+	V_End = VIDEO_GET_VSYNC_BOTTOM(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));
+
+
+	//Check if cable quality is too bad. If it is bad then we use 0x65 as threshold
+	//Because RGB data is arrived slower than H-sync, V-sync. We have to read more times to confirm RGB data is arrived
+	if ((abs(H_Temp - H_Start) > 1) || ((H_Start <= 1) || (V_Start <= 1) || (H_Start == 0xFFF) || (V_Start == 0xFFF))) {
+		H_Temp = VIDEO_GET_HSYNC_LEFT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
+		V_Temp = VIDEO_GET_VSYNC_TOP(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));
+		goto Redo;
+	}
+
+//	VIDEO_DBG("H S: %d, E: %d, V S: %d, E: %d \n", H_Start, H_End, V_Start, V_End);
+
+	ast_video_write(ast_video, VIDEO_HSYNC_PIXEL_FIRST_SET(H_Start - 1) | VIDEO_HSYNC_PIXEL_LAST_SET(H_End), AST_VIDEO_TIMING_H);
+	ast_video_write(ast_video, VIDEO_VSYNC_PIXEL_FIRST_SET(V_Start) | VIDEO_VSYNC_PIXEL_LAST_SET(V_End + 1), AST_VIDEO_TIMING_V);
+
+	ast_video->src_fbinfo.x = (H_End - H_Start) + 1;
+	ast_video->src_fbinfo.y = (V_End - V_Start) + 1;
+
+	VIDEO_DBG("screen mode x:%d, y:%d \n", ast_video->src_fbinfo.x, ast_video->src_fbinfo.y);
+
+	mode_detect->src_x = ast_video->src_fbinfo.x;
+	mode_detect->src_y = ast_video->src_fbinfo.y;
+
+	VGA_Scratch_Register_350 = ast_video_read(ast_video, AST_VIDEO_SCRATCH_350);
+	VGA_Scratch_Register_34C = ast_video_read(ast_video, AST_VIDEO_SCRATCH_34C);
+	VGA_Scratch_Register_354 = ast_video_read(ast_video, AST_VIDEO_SCRATCH_354);
+
+	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) &
+					~(VIDEO_SO_VSYNC_POLARITY | VIDEO_SO_HSYNC_POLARITY),
+					AST_VIDEO_PASS_CTRL);
+
+
+	if (((VGA_Scratch_Register_350 & 0xff00) >> 8) == 0xA8) {
+		//Driver supports to write display information in scratch register
+//		printk("Wide Screen Information \n");
+		/*
+		Index 0x94: (VIDEO:1E70:0354)
+		D[7:0]: HDE D[7:0]
+		Index 0x95: (VIDEO:1E70:0355)
+		D[7:0]: HDE D[15:8]
+		Index 0x96: (VIDEO:1E70:0356)
+		D[7:0]: VDE D[7:0]
+		Index 0x97: (VIDEO:1E70:0357)
+		D[7:0]: VDE D[15:8]
+		*/
+
+		Color_Depth = ((VGA_Scratch_Register_350 & 0xff0000) >> 16); //VGA's Color Depth is 0 when real color depth is less than 8
+		Mode_Clock = ((VGA_Scratch_Register_350 & 0xff000000) >> 24);
+		if (Color_Depth < 15) {
+//			printk("Color Depth is not 16bpp or higher\n");
+			Direct_Mode = 0;
+		} else {
+//			printk("Color Depth is 16bpp or higher\n");
+			Direct_Mode = 1;
+		}
+	} else { //Original mode information
+		//Judge if bandwidth is not enough then enable direct mode in internal VGA
+		/* Index 0x8E: (VIDEO:1E70:034E)
+		Mode ID Resolution Notes
+		0x2E 640x480
+		0x30 800x600
+		0x31 1024x768
+		0x32 1280x1024
+		0x33 1600x1200
+		0x34 1920x1200
+		0x35 1280x800
+		0x36 1440x900
+		0x37 1680x1050
+		0x38 1920x1080
+		0x39 1366x768
+		0x3A 1600x900
+		0x3B 1152x864
+		0x50 320x240
+		0x51 400x300
+		0x52 512x384
+		0x6A 800x600
+		*/
+
+		RefreshRateIndex = (VGA_Scratch_Register_34C >> 8) & 0x0F;
+		ColorDepthIndex = (VGA_Scratch_Register_34C >> 4) & 0x0F;
+//		printk("Orignal mode information \n");
+		if ((ColorDepthIndex == 0xe) || (ColorDepthIndex == 0xf)) {
+			Direct_Mode = 0;
+		} else {
+			if (ColorDepthIndex > 2) {
+				if ((ast_video->src_fbinfo.x * ast_video->src_fbinfo.y) > (1024 * 768))
+					Direct_Mode = 1;
+				else
+					Direct_Mode = 0;
+			} else {
+				Direct_Mode = 0;
+			}
+		}
 	}
 
-	if (sts & VIDEO_COMPRESS_PKT_COMPLETE) {
-		VIDEO_DBG("VIDEO_COMPRESS_PKT_COMPLETE TODO ..............\n");
-		ast_video_write(ast_video, VIDEO_COMPRESS_PKT_COMPLETE, AST_VIDEO_INT_STS);
+	if (Direct_Mode) {
+		VIDEO_DBG("Direct Mode \n");
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) | VIDEO_DIRT_FATCH | VIDEO_AUTO_FATCH, AST_VIDEO_PASS_CTRL);
+
+		ast_video_write(ast_video, get_vga_mem_base(), AST_VIDEO_DIRECT_BASE);
+
+		ast_video_write(ast_video, VIDEO_FETCH_TIMING(0) | VIDEO_FETCH_LINE_OFFSET(ast_video->src_fbinfo.x * 4), AST_VIDEO_DIRECT_CTRL);
+
+	} else {
+		VIDEO_DBG("Sync Mode \n");
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) & ~VIDEO_DIRT_FATCH, AST_VIDEO_PASS_CTRL);
 	}
 
-	if (sts & VIDEO_FRAME_COMPLETE) {
-		VIDEO_DBG("VIDEO_FRAME_COMPLETE TODO ...\n");
-		ast_video_write(ast_video, VIDEO_FRAME_COMPLETE, AST_VIDEO_INT_STS);		
+	//should enable WDT detection every after mode detection
+	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_INPUT_MODE_CHG_WDT, AST_VIDEO_SEQ_CTRL);
+
+}
+
+static void ast_video_capture_trigger(struct ast_video_data *ast_video, struct ast_capture_mode *capture_mode)
+{
+	int timeout = 0;
+
+	VIDEO_DBG("\n");
+
+	if (ast_video->mode_change) {
+		capture_mode->mode_change = ast_video->mode_change;
+		ast_video->mode_change = 0;
+		return;
 	}
-	
-	return IRQ_HANDLED;
+
+	switch (capture_mode->engine_idx) {
+	case 0:
+		init_completion(&ast_video->capture_complete);
+
+		if (capture_mode->differential)
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_BCD_CTRL) | VIDEO_BCD_CHG_EN, AST_VIDEO_BCD_CTRL);
+		else
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_BCD_CTRL) & ~VIDEO_BCD_CHG_EN, AST_VIDEO_BCD_CTRL);
+
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_FORCE_IDLE | VIDEO_COMPRESS_TRIGGER | VIDEO_AUTO_COMPRESS), AST_VIDEO_SEQ_CTRL);
+		//If CPU is too fast, pleas read back and trigger
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_CAPTURE_TRIGGER, AST_VIDEO_SEQ_CTRL);
+
+		timeout = wait_for_completion_interruptible_timeout(&ast_video->capture_complete, HZ / 2);
+
+		if (timeout == 0) {
+			printk("compression timeout sts %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+		}
+		break;
+	case 1:
+//		init_completion(&ast_video->automode_vm_complete);
+		if (capture_mode->differential) {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_BCD_CTRL) | VIDEO_BCD_CHG_EN, AST_VM_BCD_CTRL);
+		} else {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_BCD_CTRL) & ~VIDEO_BCD_CHG_EN, AST_VM_BCD_CTRL);
+		}
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_TRIGGER | VIDEO_AUTO_COMPRESS), AST_VM_SEQ_CTRL);
+
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) | VIDEO_CAPTURE_TRIGGER, AST_VM_SEQ_CTRL);
+		udelay(10);
+//AST_G5 Issue in isr bit 19, so use polling mode for wait engine idle
+#if 1
+		timeout = 0;
+		while (1) {
+			timeout++;
+			if ((ast_video_read(ast_video, AST_VM_SEQ_CTRL) & 0x50000) == 0x50000)
+				break;
+
+			mdelay(1);
+			if (timeout > 100)
+				break;
+		}
+
+		if (timeout >= 100) {
+			printk("Engine hang time out \n");
+		} 
+//			printk("0 isr %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+		//must clear it
+		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_TRIGGER)) , AST_VM_SEQ_CTRL);
+//			printk("1 isr %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+#else
+		timeout = wait_for_completion_interruptible_timeout(&ast_video->automode_vm_complete, 10 * HZ);
+
+		if (timeout == 0) {
+			printk("compression timeout sts %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+			return 0;
+		} else {
+			printk("%x size = %x \n", ast_video_read(ast_video, 0x270), ast_video_read(ast_video, AST_VM_COMPRESS_FRAME_END));
+			return ast_video_read(ast_video, AST_VM_COMPRESS_FRAME_END);
+		}
+#endif
+		break;
+	}
+
+	if (ast_video->mode_change) {
+		capture_mode->mode_change = ast_video->mode_change;
+		ast_video->mode_change = 0;
+	}
+
+}
+
+static void ast_video_compression_trigger(struct ast_video_data *ast_video, struct ast_compression_mode *compression_mode)
+{
+	int timeout = 0;
+
+	VIDEO_DBG("\n");
+	//u8 *buff = ast_video->stream_virt;
+
+	if (ast_video->mode_change) {
+		compression_mode->mode_change = ast_video->mode_change;
+		ast_video->mode_change = 0;
+		return;
+	}
+
+	switch (compression_mode->engine_idx) {
+	case 0:
+		init_completion(&ast_video->compression_complete);
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_FORCE_IDLE | VIDEO_COMPRESS_TRIGGER | VIDEO_AUTO_COMPRESS) , AST_VIDEO_SEQ_CTRL);
+		//If CPU is too fast, pleas read back and trigger
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_COMPRESS_TRIGGER, AST_VIDEO_SEQ_CTRL);
+
+		timeout = wait_for_completion_interruptible_timeout(&ast_video->compression_complete, HZ / 2);
+
+		if (timeout == 0) {
+			printk("compression timeout sts %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+			compression_mode->total_size = 0;
+			compression_mode->block_count = 0;
+		} else {
+			compression_mode->total_size = ast_video_read(ast_video, AST_VIDEO_COMPRESS_DATA_COUNT);
+			compression_mode->block_count = ast_video_read(ast_video, AST_VIDEO_COMPRESS_BLOCK_COUNT) >> 16;
+
+			if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+				if(ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & G5_VIDEO_COMPRESS_JPEG_MODE) {
+					compression_mode->total_size = ast_video_read(ast_video, AST_VIDEO_JPEG_COUNT);
+//					if((buff[compression_mode->total_size - 2] != 0xff) && (buff[compression_mode->total_size - 1] != 0xd9))
+//						printk("Error --- %x %x\n", buff[compression_mode->total_size - 2], buff[compression_mode->total_size - 1]);
+//					printk("jpeg %d compression_mode->total_size %d , block count %d \n",compression_mode->differential, compression_mode->total_size, compression_mode->block_count);
+				} else {
+//					printk("%d	compression_mode->total_size %d , block count %d \n",compression_mode->differential, compression_mode->total_size, compression_mode->block_count);					
+				}
+			} else {
+				if (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & VIDEO_COMPRESS_JPEG_MODE) {
+					compression_mode->total_size = ast_video_read(ast_video, AST_VIDEO_JPEG_COUNT);
+//					if((buff[compression_mode->total_size - 2] != 0xff) && (buff[compression_mode->total_size - 1] != 0xd9)) {
+//						printk("Error --- %x %x\n", buff[compression_mode->total_size - 2], buff[compression_mode->total_size - 1]);
+//					}
+//					printk("jpeg %d compression_mode->total_size %d , block count %d \n",compression_mode->differential, compression_mode->total_size, compression_mode->block_count);
+				} else {
+//					printk("%d	compression_mode->total_size %d , block count %d \n",compression_mode->differential, compression_mode->total_size, compression_mode->block_count);
+				}
+			}
+		}
+
+		break;
+	case 1:
+//		init_completion(&ast_video->automode_vm_complete);
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_TRIGGER | VIDEO_AUTO_COMPRESS), AST_VM_SEQ_CTRL);
+
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) | VIDEO_COMPRESS_TRIGGER, AST_VM_SEQ_CTRL);
+		udelay(10);
+//AST_G5 Issue in isr bit 19, so use polling mode for wait engine idle
+#if 1
+		timeout = 0;
+		while (1) {
+			timeout++;
+			if ((ast_video_read(ast_video, AST_VM_SEQ_CTRL) & 0x50000) == 0x50000)
+				break;
+
+			mdelay(1);
+			if (timeout > 100)
+				break;
+		}
+
+		if (timeout >= 100) {
+			printk("Engine hang time out \n");
+			compression_mode->total_size = 0;
+			compression_mode->block_count = 0;
+		} else {
+			compression_mode->total_size = ast_video_read(ast_video, AST_VM_COMPRESS_FRAME_END);
+			compression_mode->block_count = ast_video_read(ast_video, AST_VM_COMPRESS_BLOCK_COUNT);
+		}
+
+//			printk("0 isr %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+		//must clear it
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~VIDEO_COMPRESS_TRIGGER, AST_VM_SEQ_CTRL);
+//			printk("1 isr %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+#else
+		timeout = wait_for_completion_interruptible_timeout(&ast_video->automode_vm_complete, 10 * HZ);
+
+		if (timeout == 0) {
+			printk("compression timeout sts %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+			return 0;
+		} else {
+			printk("%x size = %x \n", ast_video_read(ast_video, 0x270), ast_video_read(ast_video, AST_VM_COMPRESS_FRAME_END));
+			return ast_video_read(ast_video, AST_VM_COMPRESS_FRAME_END);
+		}
+#endif
+		break;
+	}
+
+	if (ast_video->mode_change) {
+		compression_mode->mode_change = ast_video->mode_change;
+		ast_video->mode_change = 0;
+	}
+
+}
+
+/*return compression size */
+static void ast_video_auto_mode_trigger(struct ast_video_data *ast_video, struct ast_auto_mode *auto_mode)
+{
+	int timeout = 0;
+
+	VIDEO_DBG("\n");
+	//u8 *buff = ast_video->stream_virt;
+
+	if (ast_video->mode_change) {
+		auto_mode->mode_change = ast_video->mode_change;
+		ast_video->mode_change = 0;
+		return;
+	}
+
+	switch (auto_mode->engine_idx) {
+	case 0:
+		init_completion(&ast_video->automode_complete);
+
+		if (auto_mode->differential)
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_BCD_CTRL) | VIDEO_BCD_CHG_EN, AST_VIDEO_BCD_CTRL);
+		else
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_BCD_CTRL) & ~VIDEO_BCD_CHG_EN, AST_VIDEO_BCD_CTRL);
+
+		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_FORCE_IDLE | VIDEO_COMPRESS_TRIGGER)) | VIDEO_AUTO_COMPRESS, AST_VIDEO_SEQ_CTRL);
+		//If CPU is too fast, pleas read back and trigger
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_COMPRESS_TRIGGER | VIDEO_CAPTURE_TRIGGER, AST_VIDEO_SEQ_CTRL);
+
+		timeout = wait_for_completion_interruptible_timeout(&ast_video->automode_complete, HZ / 2);
+
+		if (timeout == 0) {
+			printk("compression timeout sts %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+			auto_mode->total_size = 0;
+			auto_mode->block_count = 0;
+		} else {
+			auto_mode->total_size = ast_video_read(ast_video, AST_VIDEO_COMPRESS_DATA_COUNT);
+			auto_mode->block_count = ast_video_read(ast_video, AST_VIDEO_COMPRESS_BLOCK_COUNT) >> 16;
+
+			if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+				if(ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & G5_VIDEO_COMPRESS_JPEG_MODE) {
+					auto_mode->total_size = ast_video_read(ast_video, AST_VIDEO_JPEG_COUNT);
+//					if((buff[auto_mode->total_size - 2] != 0xff) && (buff[auto_mode->total_size - 1] != 0xd9))
+//						printk("Error --- %x %x\n", buff[auto_mode->total_size - 2], buff[auto_mode->total_size - 1]);
+//					printk("jpeg %d auto_mode->total_size %d , block count %d \n",auto_mode->differential, auto_mode->total_size, auto_mode->block_count);
+				} else {
+//					printk("%d	auto_mode->total_size %d , block count %d \n",auto_mode->differential, auto_mode->total_size, auto_mode->block_count);					
+				}
+			} else {
+				if (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & VIDEO_COMPRESS_JPEG_MODE) {
+					auto_mode->total_size = ast_video_read(ast_video, AST_VIDEO_JPEG_COUNT);
+//					if((buff[auto_mode->total_size - 2] != 0xff) && (buff[auto_mode->total_size - 1] != 0xd9)) {
+//						printk("Error --- %x %x\n", buff[auto_mode->total_size - 2], buff[auto_mode->total_size - 1]);
+//					}
+//					printk("jpeg %d auto_mode->total_size %d , block count %d \n",auto_mode->differential, auto_mode->total_size, auto_mode->block_count);
+				} else {
+//					printk("%d	auto_mode->total_size %d , block count %d \n",auto_mode->differential, auto_mode->total_size, auto_mode->block_count);
+				}
+			}
+		}
+
+		break;
+	case 1:
+//			init_completion(&ast_video->automode_vm_complete);
+		if (auto_mode->differential) {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_BCD_CTRL) | VIDEO_BCD_CHG_EN, AST_VM_BCD_CTRL);
+		} else {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_BCD_CTRL) & ~VIDEO_BCD_CHG_EN, AST_VM_BCD_CTRL);
+		}
+		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_TRIGGER)) | VIDEO_AUTO_COMPRESS , AST_VM_SEQ_CTRL);
+
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) | VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_TRIGGER, AST_VM_SEQ_CTRL);
+		udelay(10);
+//AST_G5 Issue in isr bit 19, so use polling mode for wait engine idle
+#if 1
+		timeout = 0;
+		while (1) {
+			timeout++;
+			if ((ast_video_read(ast_video, AST_VM_SEQ_CTRL) & 0x50000) == 0x50000)
+				break;
+
+			mdelay(1);
+			if (timeout > 100)
+				break;
+		}
+
+		if (timeout >= 100) {
+			printk("Engine hang time out \n");
+			auto_mode->total_size = 0;
+			auto_mode->block_count = 0;
+		} else {
+			auto_mode->total_size = ast_video_read(ast_video, AST_VM_COMPRESS_FRAME_END);
+			auto_mode->block_count = ast_video_read(ast_video, AST_VM_COMPRESS_BLOCK_COUNT);
+		}
+
+//			printk("0 isr %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+		//must clear it
+		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_TRIGGER)) , AST_VM_SEQ_CTRL);
+//			printk("1 isr %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+#else
+		timeout = wait_for_completion_interruptible_timeout(&ast_video->automode_vm_complete, 10 * HZ);
+
+		if (timeout == 0) {
+			printk("compression timeout sts %x \n", ast_video_read(ast_video, AST_VIDEO_INT_STS));
+			return 0;
+		} else {
+			printk("%x size = %x \n", ast_video_read(ast_video, 0x270), ast_video_read(ast_video, AST_VM_COMPRESS_FRAME_END));
+			return ast_video_read(ast_video, AST_VM_COMPRESS_FRAME_END);
+		}
+#endif
+		break;
+	}
+
+	if (ast_video->mode_change) {
+		auto_mode->mode_change = ast_video->mode_change;
+		ast_video->mode_change = 0;
+	}
+
+}
+
+static void ast_video_mode_detect_info(struct ast_video_data *ast_video)
+
+{
+	u32 H_Start, H_End, V_Start, V_End;
+
+	H_Start = VIDEO_GET_HSYNC_LEFT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
+	H_End = VIDEO_GET_HSYNC_RIGHT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
+
+	V_Start = VIDEO_GET_VSYNC_TOP(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));
+	V_End = VIDEO_GET_VSYNC_BOTTOM(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));
+
+	VIDEO_DBG("Get H_Start = %d, H_End = %d, V_Start = %d, V_End = %d\n", H_Start, H_End, V_Start, V_End);
+
+	ast_video->src_fbinfo.x = (H_End - H_Start) + 1;
+	ast_video->src_fbinfo.y = (V_End - V_Start) + 1;
+	VIDEO_DBG("source : x = %d, y = %d , color mode = %x \n", ast_video->src_fbinfo.x, ast_video->src_fbinfo.y, ast_video->src_fbinfo.color_mode);
 }
 
-static irqreturn_t video_interrupt(int this_irq, void *dev_id)
+
+static irqreturn_t ast_video_isr(int this_irq, void *dev_id)
 {
-	unsigned int status;
+	u32 status;
+	u32 swap0, swap1;
 	struct ast_video_data *ast_video = dev_id;
 
 	status = ast_video_read(ast_video, AST_VIDEO_INT_STS);
 
-	if(status & VIDEO_MODE_DETECT_WDT) {
-		Mode_Changed = 1;
-		Mode_Changed_Flag = 1;
-		*(u32 *)(IO_ADDRESS(0x1e700308)) = 0xB;
-		if(ast_video->async_queue)
-			kill_fasync(&ast_video->async_queue, SIGIO, POLL_IN);
+	VIDEO_DBG("%x \n", status);
+
+	if (status & VIDEO_MODE_DETECT_RDY) {
+		ast_video_write(ast_video, VIDEO_MODE_DETECT_RDY, AST_VIDEO_INT_STS);
+		complete(&ast_video->mode_detect_complete);
 	}
-	if (status & VIDEO_COMPRESS_COMPLETE) {
-		Compression_Ready = 1;
-		ast_video_write(ast_video, VIDEO_COMPRESS_COMPLETE, AST_VIDEO_INT_STS);
+
+	if (status & VIDEO_MODE_DETECT_WDT) {
+		ast_video->mode_change = 1;
+		VIDEO_DBG("change 1\n");
+		ast_video_write(ast_video, VIDEO_MODE_DETECT_WDT, AST_VIDEO_INT_STS);
+	}
+
+	if (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & VIDEO_AUTO_COMPRESS) {
+		if ((status & (VIDEO_COMPRESS_COMPLETE | VIDEO_CAPTURE_COMPLETE)) == (VIDEO_COMPRESS_COMPLETE | VIDEO_CAPTURE_COMPLETE)) {
+			ast_video_write(ast_video, VIDEO_COMPRESS_COMPLETE | VIDEO_CAPTURE_COMPLETE, AST_VIDEO_INT_STS);
+			swap0 = ast_video_read(ast_video, AST_VIDEO_SOURCE_BUFF0);
+			swap1 = ast_video_read(ast_video, AST_VIDEO_SOURCE_BUFF1);
+			ast_video_write(ast_video, swap1, AST_VIDEO_SOURCE_BUFF0);
+			ast_video_write(ast_video, swap0, AST_VIDEO_SOURCE_BUFF1);
+			VIDEO_DBG("auto mode complete \n");
+			complete(&ast_video->automode_complete);
+		}
+	} else {
+		if (status & VIDEO_COMPRESS_COMPLETE) {
+			ast_video_write(ast_video, VIDEO_COMPRESS_COMPLETE, AST_VIDEO_INT_STS);
+			VIDEO_DBG("compress complete \n");
+			swap0 = ast_video_read(ast_video, AST_VIDEO_SOURCE_BUFF0);
+			swap1 = ast_video_read(ast_video, AST_VIDEO_SOURCE_BUFF1);
+			ast_video_write(ast_video, swap1, AST_VIDEO_SOURCE_BUFF0);
+			ast_video_write(ast_video, swap0, AST_VIDEO_SOURCE_BUFF1);		
+			complete(&ast_video->compression_complete);
+		}
+		if (status & VIDEO_CAPTURE_COMPLETE) {
+			ast_video_write(ast_video, VIDEO_CAPTURE_COMPLETE, AST_VIDEO_INT_STS);
+			VIDEO_DBG("capture complete \n");
+			complete(&ast_video->capture_complete);
+		}
 	}
-	if (status & VIDEO_CAPTURE_COMPLETE) {
- 		Capture_Ready = 1;
-		ast_video_write(ast_video, VIDEO_CAPTURE_COMPLETE, AST_VIDEO_INT_STS);
- 	}
-	if ((Mode_Changed == 1) || ((Capture_Ready == 1) && (Compression_Ready == 1))) {
-		ast_video->flag = 1;
-		wake_up_interruptible (&my_queue);
+
+	return IRQ_HANDLED;
+}
+
+#define AST_CRT_ADDR				0x80
+
+static void ast_set_crt_compression(struct ast_video_data *ast_video, struct fb_var_screeninfo *fb_info)
+{
+	u32 val;
+
+	//if use crt compression, need give capture engine clk and also can't less then 1/4 dram controller clk
+	//now set d-pll for 66mhz
+	regmap_write(ast_video->scu, 0x028, 0x5c822029);
+	regmap_write(ast_video->scu, 0x130, 0x00000580);
+	regmap_update_bits(ast_video->scu, AST_SCU_MISC1_CTRL, BIT(20), BIT(20));
+	
+	ast_video->src_fbinfo.x = fb_info->xres;
+	ast_video->src_fbinfo.y = fb_info->yres;
+
+	//VR008[5] = 1 
+	//VR008[8]<=0
+	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) | VIDEO_DIRT_FATCH) & ~VIDEO_AUTO_FATCH, AST_VIDEO_PASS_CTRL);
+
+	//VR008[4]<=0 when CRT60[8:7]=10. VR008[4]<=1 when CRT60[8:7]=00.
+	//regmap_read(ast_video->gfx, AST_CRT_CTRL1, &val);
+//	printk("AST_CRT_CTRL1 %x \n", val);
+	if (fb_info->bits_per_pixel == 32) {
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) & ~VIDEO_16BPP_MODE, AST_VIDEO_PASS_CTRL);
+	} else if (fb_info->bits_per_pixel == 16) {
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) | VIDEO_16BPP_MODE, AST_VIDEO_PASS_CTRL);
+	} else {
+		printk("error \n");
 	}
 
-    return IRQ_HANDLED;
+	//VR00C <= CRT80
+	regmap_read(ast_video->gfx, AST_CRT_ADDR, &val);
+//	printk("AST_CRT_ADDR %x \n", val);
+	ast_video_write(ast_video, val, AST_VIDEO_DIRECT_BASE);
+
+	//VR010[14:0] <= CRT84[14:0]
+	//var->xres * var->bits_per_pixel /8;
+//	regmap_read(ast_video->gfx, AST_CRT_OFFSET, &val);
+//	printk("AST_CRT_OFFSET %x \n", val);
+	val = fb_info->xres * fb_info->bits_per_pixel / 8;
+	ast_video_write(ast_video, val, AST_VIDEO_DIRECT_CTRL);
+
+	//VR010[15]<=0 //force VGA blank, don;t have to do
 }
 
 static void ast_video_ctrl_init(struct ast_video_data *ast_video)
@@ -1550,13 +2361,14 @@ static void ast_video_ctrl_init(struct ast_video_data *ast_video)
 	ast_video_write(ast_video, (u32)ast_video->bcd_phy, AST_VIDEO_BCD_BUFF);
 	ast_video_write(ast_video, (u32)ast_video->stream_phy, AST_VIDEO_STREAM_BUFF);
 	ast_video_write(ast_video, (u32)ast_video->jpeg_tbl_phy, AST_VIDEO_JPEG_HEADER_BUFF);
-	ast_video_write(ast_video, (u32)ast_video->jpeg_tbl_phy, AST_VM_JPEG_HEADER_BUFF);		
+	ast_video_write(ast_video, (u32)ast_video->jpeg_tbl_phy, AST_VM_JPEG_HEADER_BUFF);
 	ast_video_write(ast_video, (u32)ast_video->jpeg_buf0_phy, AST_VM_SOURCE_BUFF0);
 	ast_video_write(ast_video, (u32)ast_video->jpeg_phy, AST_VM_COMPRESS_BUFF);
 	ast_video_write(ast_video, 0, AST_VIDEO_COMPRESS_READ);
 
 	//clr int sts
 	ast_video_write(ast_video, 0xffffffff, AST_VIDEO_INT_STS);
+	ast_video_write(ast_video, 0, AST_VIDEO_BCD_CTRL);
 
 	// =============================  JPEG init ===========================================
 	ast_init_jpeg_table(ast_video);
@@ -1577,13 +2389,13 @@ static void ast_video_ctrl_init(struct ast_video_data *ast_video)
 
 
 	//Specification define bit 12:13 must always 0;
-	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) & 
-				~(VIDEO_DUAL_EDGE_MODE | VIDEO_18BIT_SINGLE_EDGE)) |
-				VIDEO_DVO_INPUT_DELAY(0x4), 
-				AST_VIDEO_PASS_CTRL); 
+	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) &
+								~(VIDEO_DUAL_EDGE_MODE | VIDEO_18BIT_SINGLE_EDGE)) |
+					VIDEO_DVO_INPUT_DELAY(0x4),
+					AST_VIDEO_PASS_CTRL);
 
-	ast_video_write(ast_video, VIDEO_STREAM_PKT_N(STREAM_32_PKTS) | 
-				VIDEO_STREAM_PKT_SIZE(STREAM_128KB), AST_VIDEO_STREAM_SIZE);
+	ast_video_write(ast_video, VIDEO_STREAM_PKT_N(STREAM_32_PKTS) |
+					VIDEO_STREAM_PKT_SIZE(STREAM_128KB), AST_VIDEO_STREAM_SIZE);
 
 
 	//rc4 init reset ..
@@ -1597,206 +2409,177 @@ static void ast_video_ctrl_init(struct ast_video_data *ast_video)
 	ast_video_write(ast_video, 0, AST_VIDEO_COMPRESS_READ);
 
 	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_MODE_DETECT) & 0xff) |
-									VIDEO_MODE_HOR_TOLER(6) |
-									VIDEO_MODE_VER_TOLER(6) |
-									VIDEO_MODE_HOR_STABLE(2) |
-									VIDEO_MODE_VER_STABLE(2) |
-									VIDEO_MODE_EDG_THROD(0x65)
-									, AST_VIDEO_MODE_DETECT);	
+					VIDEO_MODE_HOR_TOLER(6) |
+					VIDEO_MODE_VER_TOLER(6) |
+					VIDEO_MODE_HOR_STABLE(2) |
+					VIDEO_MODE_VER_STABLE(2) |
+					VIDEO_MODE_EDG_THROD(0x65)
+					, AST_VIDEO_MODE_DETECT);
+}
+
+static void ast_scu_reset_video(struct ast_video_data *ast_video)
+{
+	reset_control_assert(ast_video->reset);
+	udelay(100);
+	reset_control_deassert(ast_video->reset);
 }
 
 static long ast_video_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
 {
 	int ret = 1;
-	u32 ctrl = 0;
 	struct miscdevice *c = fp->private_data;
 	struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);
+	struct ast_scaling set_scaling;
+	struct ast_video_config video_config;
+	struct fb_var_screeninfo fb_info;
+
+	int vga_enable = 0;
+	int encrypt_en = 0;
+	struct ast_mode_detection mode_detection;
+	struct ast_auto_mode auto_mode;
 	void __user *argp = (void __user *)arg;
 
-	IO_ACCESS_DATA  Kernal_IO_Data;
-
-	memset (&Kernal_IO_Data, 0, sizeof(IO_ACCESS_DATA));
-
-	Kernal_IO_Data = *(IO_ACCESS_DATA *)arg;
 
 	switch (cmd) {
-		case IOCTL_IO_READ:
-//			printk("READ OFFSET : %x \n",Kernal_IO_Data.Address);
-            Kernal_IO_Data.Data  = *(u32 *)(IO_ADDRESS(Kernal_IO_Data.Address));
-            *(IO_ACCESS_DATA *)arg = Kernal_IO_Data;
-            ret = 0;
-			break;
-
-		case IOCTL_IO_WRITE:
-//			printk("Write OFFSET : %x, data : %x  \n",Kernal_IO_Data.Address, Kernal_IO_Data.Data);
-            *(u32 *)(IO_ADDRESS(Kernal_IO_Data.Address)) = Kernal_IO_Data.Data;			
-			ret = 0;
-			break;
-
-		case IOCTL_AUTOMODE_TRIGGER:
-#if 0
-			ctrl = ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL);
-			if(!((ctrl & VIDEO_COMPRESS_BUSY) && (ctrl & VIDEO_CAPTURE_BUSY))) {
-				printk("Video busy %x \n", ctrl);
-				ret = 1;
-			} else {
-				printk("Mode_Changed %d \n",Mode_Changed);
-				if(Mode_Changed) {
-					ret = Mode_Changed;
-					Mode_Changed = 0;
-				} else {
-					ast_video_write(ast_video, ctrl & ~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_FORCE_IDLE |VIDEO_COMPRESS_TRIGGER), AST_VIDEO_SEQ_CTRL);
-					ast_video_write(ast_video, ctrl | VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_TRIGGER, AST_VIDEO_SEQ_CTRL);
-					wait_event_interruptible (my_queue, (ast_video->flag == 1));
-					ast_video->flag = 0;
-					printk("Mode_Changed %d \n",Mode_Changed);
-					
-					if (Mode_Changed) {
-						ret = Mode_Changed;
-						Mode_Changed = 0;
-					} else 
-						ret =0;
-					if ((Capture_Ready == 1) && (Compression_Ready == 1)) {
-						Capture_Ready = 0;
-						Compression_Ready = 0;
-					}
-				}
-			}
-#else
-			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_FORCE_IDLE |VIDEO_COMPRESS_TRIGGER), AST_VIDEO_SEQ_CTRL);
-			//If CPU is too fast, pleas read back and trigger 
-			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_CAPTURE_TRIGGER |VIDEO_COMPRESS_TRIGGER, AST_VIDEO_SEQ_CTRL);
-			wait_event_interruptible (my_queue, (ast_video->flag == 1));
-    			ast_video->flag = 0;
-			if (Mode_Changed == 1) {
-			Mode_Changed = 0;
-			}
-			if ((Capture_Ready == 1) && (Compression_Ready == 1)) {
-			Capture_Ready = 0;
-			Compression_Ready = 0;
-			}
-
-			ret = Mode_Changed_Flag;
-			if (Mode_Changed_Flag == 1) {
-				Mode_Changed_Flag = 0;
-				}
-#endif			
+	case AST_VIDEO_RESET:
+		ast_scu_reset_video(ast_video);
+		//rc4 init reset ..
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_CTRL) | VIDEO_CTRL_RC4_RST , AST_VIDEO_CTRL);
+		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_CTRL) & ~VIDEO_CTRL_RC4_RST , AST_VIDEO_CTRL);
+		ast_video_ctrl_init(ast_video);
+		ret = 0;
 		break;
-
-		case IOCTL_PASS3_TRIGGER:
-    ctrl = *(u32 *)(IO_ADDRESS(0x1e700004));
-    ctrl &= 0xFFFFFFC1;
-    *(u32 *)(IO_ADDRESS(0x1e700004)) = ctrl;
-    barrier ();
-    *(u32 *)(IO_ADDRESS(0x1e700004)) = (ctrl | 0x10);
-    wait_event_interruptible (my_queue, (ast_video->flag == 1));
-    ast_video->flag = 0;
-    if (Mode_Changed == 1) {
-	Mode_Changed = 0;
-    }
-    if ((Capture_Ready == 1) && (Compression_Ready == 1)) {
-	Capture_Ready = 0;
-	Compression_Ready = 0;
-    }
-
-    ret =  Mode_Changed_Flag;
-			if (Mode_Changed_Flag == 1) {
-				Mode_Changed_Flag = 0;
-			}
-			break;
-
-        case IOCTL_I2C_READ:
-			printk("I2C READ \n");
-			break;
-
-        case IOCTL_I2C_WRITE:
-			printk("I2C Write \n");
+	case AST_VIDEO_IOC_GET_VGA_SIGNAL:
+		ret = put_user(ast_get_vga_signal(ast_video), (unsigned char __user *)arg);
+		break;
+	case AST_VIDEO_GET_MEM_SIZE_IOCRX:
+		ret = __put_user(ast_video->video_mem_size, (unsigned long __user *)arg);
+		break;
+	case AST_VIDEO_GET_JPEG_OFFSET_IOCRX:
+		ret = __put_user(ast_video->video_jpeg_offset, (unsigned long __user *)arg);
+		break;
+	case AST_VIDEO_VGA_MODE_DETECTION:
+		ret = copy_from_user(&mode_detection, argp, sizeof(struct ast_mode_detection));
+		ast_video_vga_mode_detect(ast_video, &mode_detection);
+		ret = copy_to_user(argp, &mode_detection, sizeof(struct ast_mode_detection));
+		break;
+	case AST_VIDEO_ENG_CONFIG:
+		ret = copy_from_user(&video_config, argp, sizeof(struct ast_video_config));
+		ast_video_set_eng_config(ast_video, &video_config);
+		break;
+	case AST_VIDEO_SET_SCALING:
+		ret = copy_from_user(&set_scaling, argp, sizeof(struct ast_scaling));
+		switch (set_scaling.engine) {
+		case 0:
+			ast_video_set_0_scaling(ast_video, &set_scaling);
 			break;
-
-		default:
-			ret = 3;
+		case 1:
+			ast_video_set_1_scaling(ast_video, &set_scaling);
 			break;
+		}
+		break;
+	case AST_VIDEO_AUTOMODE_TRIGGER:
+		ret = copy_from_user(&auto_mode, argp, sizeof(struct ast_auto_mode));
+		ast_video_auto_mode_trigger(ast_video, &auto_mode);
+		ret = copy_to_user(argp, &auto_mode, sizeof(struct ast_auto_mode));
+		break;
+	case AST_VIDEO_CAPTURE_TRIGGER:
+ 		ast_video_capture_trigger(ast_video, (struct ast_capture_mode *) argp);
+		break;
+	case AST_VIDEO_COMPRESSION_TRIGGER:
+		ast_video_compression_trigger(ast_video, (struct ast_compression_mode *) argp);
+		break;
+	case AST_VIDEO_SET_VGA_DISPLAY:
+		ret = __get_user(vga_enable, (int __user *)arg);
+		ast_scu_set_vga_display(ast_video, vga_enable);
+		break;
+	case AST_VIDEO_SET_ENCRYPTION:
+		ret = __get_user(encrypt_en, (int __user *)arg);
+		if (encrypt_en) {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL) | VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);
+		} else {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL) & ~VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);
+		}
+		break;
+	case AST_VIDEO_SET_ENCRYPTION_KEY:
+		memset(ast_video->EncodeKeys, 0, 256);
+		//due to system have enter key must be remove
+		ret = copy_from_user(ast_video->EncodeKeys, argp, 256 - 1);
+		printk("encryption key '%s' \n", ast_video->EncodeKeys);
+//			memcpy(ast_video->EncodeKeys, key, strlen(key) - 1);
+		ast_video_encryption_key_setup(ast_video);
+		ret = 0;
+		break;
+	case AST_VIDEO_SET_CRT_COMPRESSION:
+		ret = copy_from_user(&fb_info, argp, sizeof(struct fb_var_screeninfo));
+		ast_set_crt_compression(ast_video, &fb_info);
+		ret = 0;
+		break;
+	default:
+		ret = 3;
+		break;
 	}
 	return ret;
 
 }
 
-static int ast_video_fasync(int fd, struct file *file, int mode)
+/** @note munmap handler is done by vma close handler */
+static int ast_video_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	struct miscdevice *c = file->private_data;
 	struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);
-	return fasync_helper(fd, file, mode, &ast_video->async_queue);
-}
+	size_t size = vma->vm_end - vma->vm_start;
+	vma->vm_private_data = ast_video;
 
-/** @note munmap handler is done by vma close handler */
-static int ast_video_mmap(struct file * file, struct vm_area_struct * vma)
-{
-        struct miscdevice *c = file->private_data;
-        struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);
-        size_t size = vma->vm_end - vma->vm_start;
-        vma->vm_private_data = ast_video;
-
-        if (PAGE_ALIGN(size) > ast_video->video_mem_size) {
-                        printk(KERN_ERR "required length exceed the size "
-                                   "of physical sram (%x)\n", ast_video->video_mem_size);
-                        return -EAGAIN;
-        }
-
-        if ((ast_video->stream_phy + (vma->vm_pgoff << PAGE_SHIFT) + size)
-                > (ast_video->stream_phy + ast_video->video_mem_size)) {
-                        printk(KERN_ERR "required sram range exceed the size "
-                                   "of phisical sram\n");
-                        return -EAGAIN;
-        }
-
-        vma->vm_flags |= VM_IO;
-        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-
-        if (io_remap_pfn_range(vma, vma->vm_start,
-                        ((u32)ast_video->stream_phy >> PAGE_SHIFT),
-                        size,
-                        vma->vm_page_prot)) {
-                printk(KERN_ERR "remap_pfn_range faile at %s()\n", __func__);
-                return -EAGAIN;
-        }
-
-        return 0;
+	if (PAGE_ALIGN(size) > ast_video->video_mem_size) {
+		printk(KERN_ERR "required length exceed the size "
+			   "of physical sram (%x)\n", ast_video->video_mem_size);
+		return -EAGAIN;
+	}
+
+	if ((ast_video->stream_phy + (vma->vm_pgoff << PAGE_SHIFT) + size)
+		> (ast_video->stream_phy + ast_video->video_mem_size)) {
+		printk(KERN_ERR "required sram range exceed the size "
+			   "of phisical sram\n");
+		return -EAGAIN;
+	}
+
+	vma->vm_flags |= VM_IO;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	if (io_remap_pfn_range(vma, vma->vm_start,
+						   ((u32)ast_video->stream_phy >> PAGE_SHIFT),
+						   size,
+						   vma->vm_page_prot)) {
+		printk(KERN_ERR "remap_pfn_range faile at %s()\n", __func__);
+		return -EAGAIN;
+	}
+
+	return 0;
 }
 
 static int ast_video_open(struct inode *inode, struct file *file)
 {
-        struct miscdevice *c = file->private_data;
-        struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);
-
-        VIDEO_DBG("\n");
-        spin_lock(&ast_video->video_state_lock);
+	struct miscdevice *c = file->private_data;
+	struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);
 
-        if (ast_video->is_open) {
-                spin_unlock(&ast_video->video_state_lock);
-                return -EBUSY;
-        }
+	VIDEO_DBG("\n");
 
-        ast_video->is_open = true;
-//        wake_up_process(ast_video->thread_task);
-        spin_unlock(&ast_video->video_state_lock);
+	ast_video->is_open = true;
 
-        return 0;
+	return 0;
 
 }
 
 static int ast_video_release(struct inode *inode, struct file *file)
 {
-        struct miscdevice *c = file->private_data;
-        struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);
-
-        VIDEO_DBG("\n");
-        spin_lock(&ast_video->video_state_lock);
+	struct miscdevice *c = file->private_data;
+	struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);
 
-//        kthread_stop(ast_video->thread_task);
+	VIDEO_DBG("\n");
 
-        ast_video->is_open = false;
-        spin_unlock(&ast_video->video_state_lock);
-        return 0;
+	ast_video->is_open = false;
+	return 0;
 }
 
 static const struct file_operations ast_video_fops = {
@@ -1806,7 +2589,6 @@ static const struct file_operations ast_video_fops = {
 	.open 			= ast_video_open,
 	.release 			= ast_video_release,
 	.mmap 			= ast_video_mmap,
-	.fasync			= ast_video_fasync,
 };
 
 struct miscdevice ast_video_misc = {
@@ -1817,54 +2599,56 @@ struct miscdevice ast_video_misc = {
 
 /************************************************** SYS FS **************************************************************/
 static ssize_t show_vga_display(struct device *dev,
-	struct device_attribute *attr, char *buf)
+								struct device_attribute *attr, char *buf)
 {
 	struct ast_video_data *ast_video = dev_get_drvdata(dev);
-	return sprintf(buf, "%d: %s\n", ast_video->plat_data->get_vga_display(), ast_video->plat_data->get_vga_display()? "Enable":"Disable");
+
+	return sprintf(buf, "%d: %s\n", ast_scu_get_vga_display(ast_video), ast_scu_get_vga_display(ast_video) ? "Enable" : "Disable");
 }
 
 static ssize_t store_vga_display(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
+								 struct device_attribute *attr, const char *buf, size_t count)
 {
-	u32 val;	
+	u32 val;
 	struct ast_video_data *ast_video = dev_get_drvdata(dev);
 
 	val = simple_strtoul(buf, NULL, 10);
 
-	if(val)
-		ast_video->plat_data->vga_display(1);
+	if (val)
+		ast_scu_set_vga_display(ast_video, 1);
 	else
-		ast_video->plat_data->vga_display(0);
-	
+		ast_scu_set_vga_display(ast_video, 0);
+
 	return count;
 }
 
-static DEVICE_ATTR(vga_display, S_IRUGO | S_IWUSR, show_vga_display, store_vga_display); 
+static DEVICE_ATTR(vga_display, S_IRUGO | S_IWUSR, show_vga_display, store_vga_display);
 
 static ssize_t store_video_reset(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
+								 struct device_attribute *attr, const char *buf, size_t count)
 {
-	u32 val;	
+	u32 val;
 	struct ast_video_data *ast_video = dev_get_drvdata(dev);
 
 	val = simple_strtoul(buf, NULL, 10);
 
-	if(val) {
-		ast_video->plat_data->ctrl_reset();
+	if (val) {
+		ast_scu_reset_video(ast_video);
 		//rc4 init reset ..
 		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_CTRL) | VIDEO_CTRL_RC4_RST , AST_VIDEO_CTRL);
 		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_CTRL) & ~VIDEO_CTRL_RC4_RST , AST_VIDEO_CTRL);
+		ast_video_ctrl_init(ast_video);
 	}
-	
+
 	return count;
 }
 
-static DEVICE_ATTR(video_reset, S_IRUGO | S_IWUSR, NULL, store_video_reset); 
+static DEVICE_ATTR(video_reset, S_IRUGO | S_IWUSR, NULL, store_video_reset);
 
 static ssize_t show_video_mode_detect(struct device *dev,
-	struct device_attribute *attr, char *buf)
+									  struct device_attribute *attr, char *buf)
 {
-	int ret;
+	int ret = 0;
 	struct ast_video_data *ast_video = dev_get_drvdata(dev);
 
 	if (ret < 0)
@@ -1876,26 +2660,26 @@ static ssize_t show_video_mode_detect(struct device *dev,
 }
 
 static ssize_t store_video_mode_detect(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
+									   struct device_attribute *attr, const char *buf, size_t count)
 {
-	u32 val;	
+	u32 val;
 	struct ast_video_data *ast_video = dev_get_drvdata(dev);
 
 	val = simple_strtoul(buf, NULL, 10);
 
-	if(val)
-		ast_video_mode_detect(ast_video);
-	
+	if (val)
+		ast_video_mode_detect_trigger(ast_video);
+
 	return count;
 }
 
-static DEVICE_ATTR(video_mode_detect, S_IRUGO | S_IWUSR, show_video_mode_detect, store_video_mode_detect); 
+static DEVICE_ATTR(video_mode_detect, S_IRUGO | S_IWUSR, show_video_mode_detect, store_video_mode_detect);
 
 static struct attribute *ast_video_attributes[] = {
 	&dev_attr_vga_display.attr,
 	&dev_attr_video_reset.attr,
 	&dev_attr_video_mode_detect.attr,
-#if 0	
+#if 0
 	&dev_attr_video_jpeg_enc.dev_attr.attr,
 	&dev_attr_video_src_x.dev_attr.attr,
 	&dev_attr_video_src_y.dev_attr.attr,
@@ -1904,7 +2688,7 @@ static struct attribute *ast_video_attributes[] = {
 	&dev_attr_video_dwn_y.dev_attr.attr,
 	&dev_attr_video_rc4_en.dev_attr.attr,
 	&dev_attr_video_rc4_key.dev_attr.attr,
-#endif	
+#endif
 	NULL
 };
 
@@ -1919,229 +2703,259 @@ enum ast_video_trigger_mode {
 	VIDEO_BUFFER_MODE,
 };
 
-static u8 ast_get_trigger_mode(struct ast_video_data *ast_video, u8 eng_idx) 
+static u8 ast_get_trigger_mode(struct ast_video_data *ast_video, u8 eng_idx)
 {
 	//VR0004[3:5] 00:capture/compression/buffer
-	u32 mode=0;
-	switch(eng_idx) {
-		case 0:
-			mode = ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & (VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS);
-			if(mode == 0) {
-				return VIDEO_CAPTURE_MODE;
-			} else if(mode == VIDEO_AUTO_COMPRESS) {
-				return VIDEO_COMPRESSION_MODE;
-			} else if(mode == (VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS)) {
-				return VIDEO_BUFFER_MODE;
-			} else {
-				printk("ERROR Mode \n");
-			}
-		case 1:
-			mode = ast_video_read(ast_video, AST_VM_SEQ_CTRL) & (VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS);
-			if(mode == 0) {
-				return VIDEO_CAPTURE_MODE;
-			} else if(mode == VIDEO_AUTO_COMPRESS) {
-				return VIDEO_COMPRESSION_MODE;
-			} else if(mode == (VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS)) {
-				return VIDEO_BUFFER_MODE;
-			} else {
-				printk("ERROR Mode \n");
-			}
-			break;
+	u32 mode = 0;
+	switch (eng_idx) {
+	case 0:
+		mode = ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & (VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS);
+		if (mode == 0) {
+			return VIDEO_CAPTURE_MODE;
+		} else if (mode == VIDEO_AUTO_COMPRESS) {
+			return VIDEO_COMPRESSION_MODE;
+		} else if (mode == (VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS)) {
+			return VIDEO_BUFFER_MODE;
+		} else {
+			printk("ERROR Mode \n");
+		}
+	case 1:
+		mode = ast_video_read(ast_video, AST_VM_SEQ_CTRL) & (VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS);
+		if (mode == 0) {
+			return VIDEO_CAPTURE_MODE;
+		} else if (mode == VIDEO_AUTO_COMPRESS) {
+			return VIDEO_COMPRESSION_MODE;
+		} else if (mode == (VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS)) {
+			return VIDEO_BUFFER_MODE;
+		} else {
+			printk("ERROR Mode \n");
+		}
+		break;
 	}
+
+	return mode;
 }
 
-static void ast_set_trigger_mode(struct ast_video_data *ast_video, u8 eng_idx, u8 mode) 
+static void ast_set_trigger_mode(struct ast_video_data *ast_video, u8 eng_idx, u8 mode)
 {
-	int i, base=0;
 	//VR0004[3:5] 00/01/11:capture/frame/stream
-	switch(eng_idx) {
-		case 0:	//video 1 
-			if(mode == VIDEO_CAPTURE_MODE) {
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~(VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS), AST_VIDEO_SEQ_CTRL);
-			} else if (mode == VIDEO_COMPRESSION_MODE) {
-				ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_AUTO_COMPRESS) & ~(VIDEO_CAPTURE_MULTI_FRAME) , AST_VIDEO_SEQ_CTRL);
-			} else if (mode == VIDEO_BUFFER_MODE) {
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS ,AST_VIDEO_SEQ_CTRL);	
-			} else {
-				printk("ERROR Mode \n");
-			}
-			break;
-		case 1:	//video M
-			if(mode == VIDEO_CAPTURE_MODE) {
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~(VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS), AST_VM_SEQ_CTRL);
-			} else if (mode == VIDEO_COMPRESSION_MODE) {
-				ast_video_write(ast_video, (ast_video_read(ast_video, AST_VM_SEQ_CTRL) | VIDEO_AUTO_COMPRESS) & ~(VIDEO_CAPTURE_MULTI_FRAME) , AST_VM_SEQ_CTRL);
-			} else if (mode == VIDEO_BUFFER_MODE) {
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) | VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS ,AST_VM_SEQ_CTRL);	
-			} else {
-				printk("ERROR Mode \n");
-			}
-			break;
+	switch (eng_idx) {
+	case 0:	//video 1
+		if (mode == VIDEO_CAPTURE_MODE) {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~(VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS), AST_VIDEO_SEQ_CTRL);
+		} else if (mode == VIDEO_COMPRESSION_MODE) {
+			ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_AUTO_COMPRESS) & ~(VIDEO_CAPTURE_MULTI_FRAME) , AST_VIDEO_SEQ_CTRL);
+		} else if (mode == VIDEO_BUFFER_MODE) {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS , AST_VIDEO_SEQ_CTRL);
+		} else {
+			printk("ERROR Mode \n");
+		}
+		break;
+	case 1:	//video M
+		if (mode == VIDEO_CAPTURE_MODE) {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~(VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS), AST_VM_SEQ_CTRL);
+		} else if (mode == VIDEO_COMPRESSION_MODE) {
+			ast_video_write(ast_video, (ast_video_read(ast_video, AST_VM_SEQ_CTRL) | VIDEO_AUTO_COMPRESS) & ~(VIDEO_CAPTURE_MULTI_FRAME) , AST_VM_SEQ_CTRL);
+		} else if (mode == VIDEO_BUFFER_MODE) {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) | VIDEO_CAPTURE_MULTI_FRAME | VIDEO_AUTO_COMPRESS , AST_VM_SEQ_CTRL);
+		} else {
+			printk("ERROR Mode \n");
+		}
+		break;
 	}
 }
 
-static u8 ast_get_compress_yuv_mode(struct ast_video_data *ast_video, u8 eng_idx) 
+static u8 ast_get_compress_yuv_mode(struct ast_video_data *ast_video, u8 eng_idx)
 {
-	switch(eng_idx) {
-		case 0:
-			return VIDEO_GET_COMPRESS_FORMAT(ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL));
-			break;
-		case 1:
-			return VIDEO_GET_COMPRESS_FORMAT(ast_video_read(ast_video, AST_VM_SEQ_CTRL));
-			break;
-	}			
+	switch (eng_idx) {
+	case 0:
+		return VIDEO_GET_COMPRESS_FORMAT(ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL));
+		break;
+	case 1:
+		return VIDEO_GET_COMPRESS_FORMAT(ast_video_read(ast_video, AST_VM_SEQ_CTRL));
+		break;
+	}
+	return 0;
 }
 
-static void ast_set_compress_yuv_mode(struct ast_video_data *ast_video, u8 eng_idx, u8 yuv_mode) 
+static void ast_set_compress_yuv_mode(struct ast_video_data *ast_video, u8 eng_idx, u8 yuv_mode)
 {
-	int i, base=0;
+	int i, base = 0;
 
-	switch(eng_idx) {
-		case 0:	//video 1 
-			if(yuv_mode) 	//YUV420
-				ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~VIDEO_COMPRESS_FORMAT_MASK) | VIDEO_COMPRESS_FORMAT(YUV420) , AST_VIDEO_SEQ_CTRL);
-			else
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~VIDEO_COMPRESS_FORMAT_MASK , AST_VIDEO_SEQ_CTRL);
-			break;
-		case 1:	//video M
-			if(yuv_mode) 	//YUV420
-				ast_video_write(ast_video, (ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~VIDEO_COMPRESS_FORMAT_MASK) | VIDEO_COMPRESS_FORMAT(YUV420) , AST_VM_SEQ_CTRL);
+	switch (eng_idx) {
+	case 0:	//video 1
+		if (yuv_mode) 	//YUV420
+			ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~VIDEO_COMPRESS_FORMAT_MASK) | VIDEO_COMPRESS_FORMAT(YUV420) , AST_VIDEO_SEQ_CTRL);
+		else
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~VIDEO_COMPRESS_FORMAT_MASK , AST_VIDEO_SEQ_CTRL);
+		break;
+	case 1:	//video M
+		if (yuv_mode) 	//YUV420
+			ast_video_write(ast_video, (ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~VIDEO_COMPRESS_FORMAT_MASK) | VIDEO_COMPRESS_FORMAT(YUV420) , AST_VM_SEQ_CTRL);
+		else
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~VIDEO_COMPRESS_FORMAT_MASK, AST_VM_SEQ_CTRL);
+
+		for (i = 0; i < 12; i++) {
+			base = (256 * i);
+			if (yuv_mode)	//yuv420
+				ast_video->jpeg_tbl_virt[base + 46] = 0x00220103; //for YUV420 mode
 			else
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~VIDEO_COMPRESS_FORMAT_MASK, AST_VM_SEQ_CTRL);
-
-			for(i = 0; i<12; i++) {
-				base = (1024*i);
-				if(yuv_mode)	//yuv420
-					ast_video->jpeg_tbl_virt[base + 46] = 0x00220103; //for YUV420 mode
-				else 
-					ast_video->jpeg_tbl_virt[base + 46] = 0x00110103; //for YUV444 mode)
-			}
-			
-			break;
+				ast_video->jpeg_tbl_virt[base + 46] = 0x00110103; //for YUV444 mode)
+		}
+
+		break;
 	}
 }
 
-static u8 ast_get_compress_jpeg_mode(struct ast_video_data *ast_video, u8 eng_idx) 
+static u8 ast_get_compress_jpeg_mode(struct ast_video_data *ast_video, u8 eng_idx)
 {
-	switch(eng_idx) {
-		case 0:
-			if(ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & VIDEO_COMPRESS_JPEG_MODE)
+	switch (eng_idx) {
+	case 0:
+		if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+			if (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & G5_VIDEO_COMPRESS_JPEG_MODE)
 				return 1;
 			else
 				return 0;
-			break;
-		case 1:
-			if(ast_video_read(ast_video, AST_VM_SEQ_CTRL) & VIDEO_COMPRESS_JPEG_MODE)
+		} else {
+			if (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & VIDEO_COMPRESS_JPEG_MODE)
 				return 1;
 			else
 				return 0;
-			break;
-	}			
-}
-
-static void ast_set_compress_jpeg_mode(struct ast_video_data *ast_video, u8 eng_idx, u8 jpeg_mode) 
-{
-	int i, base=0;
-
-	switch(eng_idx) {
-		case 0:	//video 1 
-			if(jpeg_mode) 	
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_COMPRESS_JPEG_MODE, AST_VIDEO_SEQ_CTRL);
-			else
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~VIDEO_COMPRESS_JPEG_MODE , AST_VIDEO_SEQ_CTRL);
-			break;
-		case 1:	//video M
-			if(jpeg_mode) 	
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) | VIDEO_COMPRESS_JPEG_MODE, AST_VM_SEQ_CTRL);
-			else
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~VIDEO_COMPRESS_JPEG_MODE , AST_VM_SEQ_CTRL);			
-			break;
-	}
-}
-
-static u8 ast_get_compress_encrypt_en(struct ast_video_data *ast_video, u8 eng_idx) 
-{
-	switch(eng_idx) {
-		case 0:
-			if(ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL) & VIDEO_ENCRYP_ENABLE)
+		}
+		break;
+	case 1:
+		if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+			if (ast_video_read(ast_video, AST_VM_SEQ_CTRL) & G5_VIDEO_COMPRESS_JPEG_MODE)
 				return 1;
 			else
 				return 0;
-			break;
-		case 1:
-			if(ast_video_read(ast_video, AST_VM_COMPRESS_CTRL) & VIDEO_ENCRYP_ENABLE)
+		} else {
+			if (ast_video_read(ast_video, AST_VM_SEQ_CTRL) & VIDEO_COMPRESS_JPEG_MODE)
 				return 1;
 			else
 				return 0;
-			break;
-	}			
+		}
+		break;
+	}
+	return 0;
 }
 
-static void ast_set_compress_encrypt_en(struct ast_video_data *ast_video, u8 eng_idx, u8 enable) 
+static void ast_set_compress_jpeg_mode(struct ast_video_data *ast_video, u8 eng_idx, u8 jpeg_mode)
 {
-	int i, base=0;
-
-	switch(eng_idx) {
-		case 0:	//video 1 
-			if(enable) {
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL) | VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);		
+	switch (eng_idx) {
+	case 0:	//video 1
+		if (jpeg_mode) {
+			if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | G5_VIDEO_COMPRESS_JPEG_MODE, AST_VIDEO_SEQ_CTRL);
 			} else {
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL) & ~VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);
+				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | VIDEO_COMPRESS_JPEG_MODE, AST_VIDEO_SEQ_CTRL);
 			}
-		case 1:	//video M
-			if(enable) {
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_COMPRESS_CTRL) | VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);		
+		} else {
+			if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~G5_VIDEO_COMPRESS_JPEG_MODE , AST_VIDEO_SEQ_CTRL);
 			} else {
-				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_COMPRESS_CTRL) & ~VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);
+				ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~VIDEO_COMPRESS_JPEG_MODE , AST_VIDEO_SEQ_CTRL);
 			}
+
+		}
+		break;
+	case 1:	//video M
+		if (jpeg_mode) {
+			if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) | G5_VIDEO_COMPRESS_JPEG_MODE, AST_VM_SEQ_CTRL);
+			} else
+				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) | VIDEO_COMPRESS_JPEG_MODE, AST_VM_SEQ_CTRL);
+		} else {
+			if ((ast_video->config->version == 5) || (ast_video->config->version == 6)) {
+				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~G5_VIDEO_COMPRESS_JPEG_MODE , AST_VM_SEQ_CTRL);
+			} else
+				ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) & ~VIDEO_COMPRESS_JPEG_MODE , AST_VM_SEQ_CTRL);
+		}
+		break;
+	}
+}
+
+static u8 ast_get_compress_encrypt_en(struct ast_video_data *ast_video, u8 eng_idx)
+{
+	switch (eng_idx) {
+	case 0:
+		if (ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL) & VIDEO_ENCRYP_ENABLE)
+			return 1;
+		else
+			return 0;
+		break;
+	case 1:
+		if (ast_video_read(ast_video, AST_VM_COMPRESS_CTRL) & VIDEO_ENCRYP_ENABLE)
+			return 1;
+		else
+			return 0;
+		break;
+	}
+}
+
+static void ast_set_compress_encrypt_en(struct ast_video_data *ast_video, u8 eng_idx, u8 enable)
+{
+	switch (eng_idx) {
+	case 0:	//video 1
+		if (enable) {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL) | VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);
+		} else {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL) & ~VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);
+		}
+	case 1:	//video M
+		if (enable) {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_COMPRESS_CTRL) | VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);
+		} else {
+			ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_COMPRESS_CTRL) & ~VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);
+		}
 	}
 }
 
-static u8 *ast_get_compress_encrypt_key(struct ast_video_data *ast_video, u8 eng_idx) 
+static u8 *ast_get_compress_encrypt_key(struct ast_video_data *ast_video, u8 eng_idx)
 {
-	switch(eng_idx) {
+	switch (eng_idx) {
 		case 0:
 			return ast_video->EncodeKeys;
 			break;
 		case 1:
 			return ast_video->EncodeKeys;
 			break;
-	}			
+		}
+	return 0;
 }
 
-static void ast_set_compress_encrypt_key(struct ast_video_data *ast_video, u8 eng_idx, u8 *key) 
+static void ast_set_compress_encrypt_key(struct ast_video_data *ast_video, u8 eng_idx, u8 *key)
 {
-	int i, base=0;
-
-	switch(eng_idx) {
-		case 0:	//video 1 
+	switch (eng_idx) {
+		case 0:	//video 1
 			memset(ast_video->EncodeKeys, 0, 256);
 			//due to system have enter key must be remove
 			memcpy(ast_video->EncodeKeys, key, strlen(key) - 1);
 			ast_video_encryption_key_setup(ast_video);
 			break;
 		case 1:	//video M
-			break;		
+			break;
 	}
+	return 0;
 }
 
-static u8 ast_get_compress_encrypt_mode(struct ast_video_data *ast_video) 
+static u8 ast_get_compress_encrypt_mode(struct ast_video_data *ast_video)
 {
-	if(ast_video_read(ast_video, AST_VIDEO_CTRL) & VIDEO_CTRL_CRYPTO_AES)
+	if (ast_video_read(ast_video, AST_VIDEO_CTRL) & VIDEO_CTRL_CRYPTO_AES)
 		return 1;
 	else
 		return 0;
 }
 
-static void ast_set_compress_encrypt_mode(struct ast_video_data *ast_video, u8 mode) 
+static void ast_set_compress_encrypt_mode(struct ast_video_data *ast_video, u8 mode)
 {
-	if(mode)
+	if (mode)
 		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_CTRL) | VIDEO_CTRL_CRYPTO_AES, AST_VIDEO_CTRL);
 	else
 		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_CTRL) & ~VIDEO_CTRL_CRYPTO_AES, AST_VIDEO_CTRL);
 }
 
-static ssize_t 
+static ssize_t
 ast_store_compress(struct device *dev, struct device_attribute *attr, const char *sysfsbuf, size_t count)
 {
 	u32 input_val;
@@ -2149,39 +2963,38 @@ ast_store_compress(struct device *dev, struct device_attribute *attr, const char
 	struct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);
 
 	input_val = simple_strtoul(sysfsbuf, NULL, 10);
-//	input_val = StrToHex(sysfsbuf);		
+//	input_val = StrToHex(sysfsbuf);
 	//sensor_attr->index : ch#
 	//sensor_attr->nr : attr#
-	switch(sensor_attr->nr) 
-	{
-		case 0:	//compress mode
-			ast_set_trigger_mode(ast_video, sensor_attr->index, input_val);
-			break;
-		case 1: //yuv mode
-			ast_set_compress_yuv_mode(ast_video, sensor_attr->index, input_val);
-			break;
-		case 2: //jpeg/aspeed mode
-			ast_set_compress_jpeg_mode(ast_video, sensor_attr->index, input_val);
-			break;
-		case 3: //
-			ast_set_compress_encrypt_en(ast_video, sensor_attr->index, input_val);
-			break;
-		case 4: //
-			ast_set_compress_encrypt_key(ast_video, sensor_attr->index, sysfsbuf);
-			break;
-		case 5: //
-			ast_set_compress_encrypt_mode(ast_video, sensor_attr->index);
-			break;
+	switch (sensor_attr->nr) {
+	case 0:	//compress mode
+		ast_set_trigger_mode(ast_video, sensor_attr->index, input_val);
+		break;
+	case 1: //yuv mode
+		ast_set_compress_yuv_mode(ast_video, sensor_attr->index, input_val);
+		break;
+	case 2: //jpeg/aspeed mode
+		ast_set_compress_jpeg_mode(ast_video, sensor_attr->index, input_val);
+		break;
+	case 3: //
+		ast_set_compress_encrypt_en(ast_video, sensor_attr->index, input_val);
+		break;
+	case 4: //
+		ast_set_compress_encrypt_key(ast_video, sensor_attr->index, (u8 *)sysfsbuf);
+		break;
+	case 5: //
+		ast_set_compress_encrypt_mode(ast_video, sensor_attr->index);
+		break;
 
-		default:
-			return -EINVAL;
-			break;
+	default:
+		return -EINVAL;
+		break;
 	}
 
 	return count;
 }
 
-static ssize_t 
+static ssize_t
 ast_show_compress(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
 {
 	struct ast_video_data *ast_video = dev_get_drvdata(dev);
@@ -2189,29 +3002,28 @@ ast_show_compress(struct device *dev, struct device_attribute *attr, char *sysfs
 
 	//sensor_attr->index : ch#
 	//sensor_attr->nr : attr#
-	switch(sensor_attr->nr) 
-	{
-		case 0:
-			return sprintf(sysfsbuf, "%d [0:Single, 1:Frame, 2:Stream]\n", ast_get_trigger_mode(ast_video, sensor_attr->index));
-			break;
-		case 1: 
-			return sprintf(sysfsbuf, "%d:%s \n", ast_get_compress_yuv_mode(ast_video, sensor_attr->index), ast_get_compress_yuv_mode(ast_video, sensor_attr->index) ? "YUV420":"YUV444");
-			break;			
-		case 2: 
-			return sprintf(sysfsbuf, "%d:%s \n", ast_get_compress_jpeg_mode(ast_video, sensor_attr->index), ast_get_compress_jpeg_mode(ast_video, sensor_attr->index) ? "JPEG":"ASPEED");
-			break;
-		case 3:
-			return sprintf(sysfsbuf, "%d:%s \n", ast_get_compress_encrypt_en(ast_video, sensor_attr->index), ast_get_compress_encrypt_en(ast_video, sensor_attr->index) ? "Enable":"Disable");
-			break;			
-		case 4:
-			return sprintf(sysfsbuf, "%s \n", ast_get_compress_encrypt_key(ast_video, sensor_attr->index));
-			break;			
-		case 5:
-			return sprintf(sysfsbuf, "%d:%s \n", ast_get_compress_encrypt_mode(ast_video), ast_get_compress_encrypt_mode(ast_video) ? "AES":"RC4");
-			break;			
-		default:
-			return -EINVAL;
-			break;
+	switch (sensor_attr->nr) {
+	case 0:
+		return sprintf(sysfsbuf, "%d [0:Single, 1:Frame, 2:Stream]\n", ast_get_trigger_mode(ast_video, sensor_attr->index));
+		break;
+	case 1:
+		return sprintf(sysfsbuf, "%d:%s \n", ast_get_compress_yuv_mode(ast_video, sensor_attr->index), ast_get_compress_yuv_mode(ast_video, sensor_attr->index) ? "YUV420" : "YUV444");
+		break;
+	case 2:
+		return sprintf(sysfsbuf, "%d:%s \n", ast_get_compress_jpeg_mode(ast_video, sensor_attr->index), ast_get_compress_jpeg_mode(ast_video, sensor_attr->index) ? "JPEG" : "ASPEED");
+		break;
+	case 3:
+		return sprintf(sysfsbuf, "%d:%s \n", ast_get_compress_encrypt_en(ast_video, sensor_attr->index), ast_get_compress_encrypt_en(ast_video, sensor_attr->index) ? "Enable" : "Disable");
+		break;
+	case 4:
+		return sprintf(sysfsbuf, "%s \n", ast_get_compress_encrypt_key(ast_video, sensor_attr->index));
+		break;
+	case 5:
+		return sprintf(sysfsbuf, "%d:%s \n", ast_get_compress_encrypt_mode(ast_video), ast_get_compress_encrypt_mode(ast_video) ? "AES" : "RC4");
+		break;
+	default:
+		return -EINVAL;
+		break;
 	}
 	return -EINVAL;
 }
@@ -2243,100 +3055,94 @@ static struct attribute *compress##index##_attributes[] = { \
 sysfs_compress(0);
 sysfs_compress(1);
 /************************************************** SYS FS Capture ***********************************************************/
-static void ast_set_capture_win(struct ast_video_data *ast_video, u8 eng_idx, u8 win_x, u8 win_y)
-{
-}
+static const struct attribute_group compress_attribute_groups[] = {
+	{ .attrs = compress0_attributes },
+	{ .attrs = compress1_attributes },
+};
 
-static void ast_get_capture_win(struct ast_video_data *ast_video, u8 eng_idx, u8 win_x, u8 win_y)
-{
-}
+/************************************************** SYS FS End ***********************************************************/
+static const struct aspeed_video_config ast2600_config = { 
+	.version = 6, 
+	.dram_base =0x80000000, 
+};
 
-static ssize_t 
-ast_store_capture(struct device *dev, struct device_attribute *attr, const char *sysfsbuf, size_t count)
-{
-	u32 input_val;
-	struct ast_video_data *ast_video = dev_get_drvdata(dev);
-	struct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);
+static const struct aspeed_video_config ast2500_config = { 
+	.version = 5, 
+	.dram_base =0x80000000, 
+};
 
-	input_val = simple_strtoul(sysfsbuf, NULL, 10);
-//	input_val = StrToHex(sysfsbuf);		
-	//sensor_attr->index : ch#
-	//sensor_attr->nr : attr#
-	switch(sensor_attr->nr) 
-	{
-		case 0:	
-//			ast_set_capture_win(ast_video, sensor_attr->index, win_x,win_y);
-			break;
-		case 1: 
+static const struct aspeed_video_config ast2400_config = { 
+	.version = 4, 
+	.dram_base =0x40000000, 
+};
 
-			break;
-		case 2: 
+static const struct of_device_id aspeed_video_matches[] = {
+	{ .compatible = "aspeed,ast2400-video",	.data = &ast2400_config, },
+	{ .compatible = "aspeed,ast2500-video",	.data = &ast2500_config, },
+	{ .compatible = "aspeed,ast2600-video",	.data = &ast2600_config, },
+	{},
+};
 
-			break;
-		default:
-			return -EINVAL;
-			break;
-	}
+MODULE_DEVICE_TABLE(of, aspeed_video_matches);
 
-	return count;
-}
+#define CONFIG_AST_VIDEO_MEM_SIZE	0x2800000
 
-static ssize_t 
-ast_show_capture(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
+static int ast_video_probe(struct platform_device *pdev)
 {
-	struct ast_video_data *ast_video = dev_get_drvdata(dev);
-	struct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);
-
-	//sensor_attr->index : ch#
-	//sensor_attr->nr : attr#
-	switch(sensor_attr->nr) 
-	{
-		case 0:
-			return sprintf(sysfsbuf, "%d [0:Single, 1:Frame, 2:Stream]\n", ast_get_trigger_mode(ast_video, sensor_attr->index));
-			break;
-		case 1: 
+	struct resource *res0;
+	int ret = 0;
+	int i;
+	struct ast_video_data *ast_video;
+	const struct of_device_id *video_dev_id;	
 
-			break;			
-		case 2: 
+	printk("VIDEO: start ast_video_probe");
 
-			break;			
-		default:
-			return -EINVAL;
-			break;
+	if (!(ast_video = devm_kzalloc(&pdev->dev, sizeof(struct ast_video_data), GFP_KERNEL))) {
+		return -ENOMEM;
 	}
-	return -EINVAL;
-}
-
-static const struct attribute_group compress_attribute_groups[] = {
-	{ .attrs = compress0_attributes },
-	{ .attrs = compress1_attributes },	
-};
 
-#define sysfs_capture(index) \
-static SENSOR_DEVICE_ATTR_2(capture##index##_win, S_IRUGO | S_IWUSR, \
-	ast_show_capture, ast_store_capture, 0, index); \
-\
-static struct attribute *capture##index##_attributes[] = { \
-	&sensor_dev_attr_capture##index##_win.dev_attr.attr, \
-	NULL \
-};
+	video_dev_id = of_match_node(aspeed_video_matches, pdev->dev.of_node);
+	if (!video_dev_id)
+		return -EINVAL;
 
-sysfs_capture(0);
-sysfs_capture(1);
+	ast_video->config = (struct aspeed_video_config *) video_dev_id->data;
 
-static const struct attribute_group capture_attribute_groups[] = {
-	{ .attrs = capture0_attributes },
-	{ .attrs = capture1_attributes },	
-};
+	printk("VIDEO: ast_video_probe trace 1");
 
-/************************************************** SYS FS End ***********************************************************/
-static int ast_video_probe(struct platform_device *pdev)
-{
-	struct resource *res0, *res1;
-	int ret=0;
-	int i;
-	u8 color_mode;
-	struct ast_video_data *ast_video;
+	if (ast_video->config->version == 6) {
+		ast_video->gfx = syscon_regmap_lookup_by_compatible("aspeed,ast-g6-gfx");
+		if (IS_ERR(ast_video->gfx)) {
+			dev_err(&pdev->dev, "failed to find 2600 GFX regmap\n");
+			return PTR_ERR(ast_video->gfx);
+		}
+		ast_video->scu = syscon_regmap_lookup_by_compatible("aspeed,ast2600-scu");
+		if (IS_ERR(ast_video->scu)) {
+			dev_err(&pdev->dev, "failed to find 2600 SCU regmap\n");
+			return PTR_ERR(ast_video->scu);
+		}
+	} else if (ast_video->config->version == 5) {
+		ast_video->gfx = syscon_regmap_lookup_by_compatible("aspeed,ast-g5-gfx");
+		if (IS_ERR(ast_video->gfx)) {
+			dev_err(&pdev->dev, "failed to find 2500 GFX regmap\n");
+			return PTR_ERR(ast_video->gfx);
+		}
+		ast_video->scu = syscon_regmap_lookup_by_compatible("aspeed,ast2500-scu");
+		if (IS_ERR(ast_video->scu)) {
+			dev_err(&pdev->dev, "failed to find 2500 SCU regmap\n");
+			return PTR_ERR(ast_video->scu);
+		}
+	} else {
+		ast_video->gfx = syscon_regmap_lookup_by_compatible("aspeed,ast-g4-gfx");
+		if (IS_ERR(ast_video->gfx)) {
+			dev_err(&pdev->dev, "failed to find 2400 GFX regmap\n");
+			return PTR_ERR(ast_video->gfx);
+		}
+		ast_video->scu = syscon_regmap_lookup_by_compatible("aspeed,ast2400-scu");
+		if (IS_ERR(ast_video->scu)) {
+			dev_err(&pdev->dev, "failed to find 2400 SCU regmap\n");
+			return PTR_ERR(ast_video->scu);
+		}
+	}
 
 	res0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (NULL == res0) {
@@ -2344,68 +3150,60 @@ static int ast_video_probe(struct platform_device *pdev)
 		ret = -ENOENT;
 		goto out;
 	}
+	ast_video->reg_base = devm_ioremap_resource(&pdev->dev, res0);
+	if (!ast_video->reg_base) {
+		ret = -EIO;
+		goto out;
+	}
+
+	//Phy assign
+	ast_video->video_mem_size = CONFIG_AST_VIDEO_MEM_SIZE;
+	VIDEO_DBG("video_mem_size %d MB\n", ast_video->video_mem_size / 1024 / 1024);
 
-	if (!request_mem_region(res0->start, resource_size(res0), res0->name)) {
-		dev_err(&pdev->dev, "cannot reserved region\n");
-		ret = -ENXIO;
+	ret = of_reserved_mem_device_init(&pdev->dev);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to reserve memory\n");
 		goto out;
 	}
 
-	if(!(ast_video = kzalloc(sizeof(struct ast_video_data), GFP_KERNEL))) {
-		return -ENOMEM;
+	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to set DMA mask\n");
+		of_reserved_mem_device_release(&pdev->dev);
 		goto out;
-        }
-	
-	ast_video->reg_base = ioremap(res0->start, resource_size(res0));
-	if (!ast_video->reg_base) {
-		ret = -EIO;
-		goto out_region0;
 	}
-	
-	res1 = platform_get_resource(pdev, IORESOURCE_DMA, 0);
-	if (!res1)
-		return -ENODEV;
-	
-	if (!request_mem_region(res1->start, resource_size(res1), res1->name)) {
-		dev_err(&pdev->dev, "cannot reserved region\n");
-		ret = -ENXIO;
-		goto out_region0;
+
+	ast_video->video_mem.virt = dma_alloc_coherent(&pdev->dev, CONFIG_AST_VIDEO_MEM_SIZE, &ast_video->video_mem.dma, GFP_KERNEL);
+	if(!ast_video->video_mem.virt){
+		printk(KERN_NOTICE "video dma_alloc_coherent got error\n");
+		return -ENOMEM;
 	}
 
-	//Phy assign
-	ast_video->video_mem_size = resource_size(res1);
-	VIDEO_DBG("video_mem_size %d MB\n",ast_video->video_mem_size/1024/1024);
-	
-	ast_video->stream_phy = res1->start;
-	ast_video->buff0_phy = res1->start + 0x400000;  //4M : size 10MB
-	ast_video->buff1_phy = res1->start + 0xe00000;  //14M : size 10MB
-	ast_video->bcd_phy = res1->start + 0x1800000;   //24M : size 1MB
-	ast_video->jpeg_buf0_phy = res1->start + 0x1900000;  //25MB: size 10 MB
-	ast_video->jpeg_phy = res1->start + 0x2300000;  //35MB: size 4 MB
-	ast_video->jpeg_tbl_phy = res1->start + 0x2700000;      //39MB: size 1 MB
+	ast_video->stream_phy = ast_video->video_mem.dma;
+	ast_video->buff0_phy = (phys_addr_t *)(ast_video->video_mem.dma + 0x400000);   //4M : size 10MB
+	ast_video->buff1_phy = (phys_addr_t *)(ast_video->video_mem.dma + 0xe00000);   //14M : size 10MB
+	ast_video->bcd_phy = (phys_addr_t *)(ast_video->video_mem.dma + 0x1800000);    //24M : size 1MB
+	ast_video->jpeg_buf0_phy = (phys_addr_t *)(ast_video->video_mem.dma + 0x1900000);   //25MB: size 10 MB
+	ast_video->video_jpeg_offset = 0x2300000;						//TODO define
+	ast_video->jpeg_phy = (phys_addr_t *)(ast_video->video_mem.dma + 0x2300000);   //35MB: size 4 MB
+	ast_video->jpeg_tbl_phy = (phys_addr_t *)(ast_video->video_mem.dma + 0x2700000);       //39MB: size 1 MB
 
 	VIDEO_DBG("\nstream_phy: %x, buff0_phy: %x, buff1_phy:%x, bcd_phy:%x \njpeg_phy:%x, jpeg_tbl_phy:%x \n",
-	        (u32)ast_video->stream_phy, (u32)ast_video->buff0_phy, (u32)ast_video->buff1_phy, (u32)ast_video->bcd_phy, (u32)ast_video->jpeg_phy, (u32)ast_video->jpeg_tbl_phy);
-
+			  (u32)ast_video->stream_phy, (u32)ast_video->buff0_phy, (u32)ast_video->buff1_phy, (u32)ast_video->bcd_phy, (u32)ast_video->jpeg_phy, (u32)ast_video->jpeg_tbl_phy);
 
 	//virt assign
-	ast_video->stream_virt = ioremap(res1->start, resource_size(res1));
-	if (!ast_video->stream_virt) {
-	        ret = -EIO;
-	        goto out_region1;
-	}
-
+	ast_video->stream_virt = ast_video->video_mem.virt;
 	ast_video->buff0_virt = (u32)ast_video->stream_virt + 0x400000; //4M : size 10MB
 	ast_video->buff1_virt = (u32)ast_video->stream_virt + 0xe00000; //14M : size 10MB
 	ast_video->bcd_virt = (u32)ast_video->stream_virt + 0x1800000;  //24M : size 4MB
-	ast_video->jpeg_buf0_virt = res1->start + 0x1900000;  //25MB: size x MB
+	ast_video->jpeg_buf0_virt = ast_video->stream_virt + 0x1900000;  //25MB: size x MB
 	ast_video->jpeg_virt = (u32)ast_video->stream_virt + 0x2300000; //35MB: size 4 MB
 	ast_video->jpeg_tbl_virt = (u32)ast_video->stream_virt + 0x2700000;     //39MB: size 1 MB
 
 	VIDEO_DBG("\nstream_virt: %x, buff0_virt: %x, buff1_virt:%x, bcd_virt:%x \njpeg_virt:%x, jpeg_tbl_virt:%x \n",
-	        (u32)ast_video->stream_virt, (u32)ast_video->buff0_virt, (u32)ast_video->buff1_virt, (u32)ast_video->bcd_virt, (u32)ast_video->jpeg_virt, (u32)ast_video->jpeg_tbl_virt);
+			  (u32)ast_video->stream_virt, (u32)ast_video->buff0_virt, (u32)ast_video->buff1_virt, (u32)ast_video->bcd_virt, (u32)ast_video->jpeg_virt, (u32)ast_video->jpeg_tbl_virt);
 
-	memset(ast_video->stream_virt, 0, resource_size(res1));	
+	memset(ast_video->stream_virt, 0, ast_video->video_mem_size);
 
 	ast_video->irq = platform_get_irq(pdev, 0);
 	if (ast_video->irq < 0) {
@@ -2414,44 +3212,51 @@ static int ast_video_probe(struct platform_device *pdev)
 		goto out_region1;
 	}
 
-	ast_video->plat_data = pdev->dev.platform_data;	
+	ast_video->reset = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(ast_video->reset)) {
+		dev_err(&pdev->dev, "can't get mctp reset\n");
+		return PTR_ERR(ast_video->reset);
+	}
+
+	ast_video->eclk = devm_clk_get(&pdev->dev, "eclk");
+	if (IS_ERR(ast_video->eclk)) {
+		dev_err(&pdev->dev, "no eclk clock defined\n");
+		return PTR_ERR(ast_video->eclk);
+	}
+
+	clk_prepare_enable(ast_video->eclk);
+
+	ast_video->vclk = devm_clk_get(&pdev->dev, "vclk");
+	if (IS_ERR(ast_video->vclk)) {
+		dev_err(&pdev->dev, "no vclk clock defined\n");
+		return PTR_ERR(ast_video->vclk);
+	}
+
+	clk_prepare_enable(ast_video->vclk);
 
-	// default config 
+//	ast_scu_init_video(0);
+
+	// default config
 	ast_video->input_source = VIDEO_SOURCE_INT_VGA;
 	ast_video->rc4_enable = 0;
 	strcpy(ast_video->EncodeKeys, "fedcba9876543210");
 	ast_video->scaling = 0;
-	
-	//TEST
-	ast_video->plat_data->get_vga_base();
 
 	ret = misc_register(&ast_video_misc);
-	if (ret){		
+	if (ret) {
 		printk(KERN_ERR "VIDEO : failed to request interrupt\n");
-		goto out_irq;
+		goto out_region1;
 	}
 
-	//bandwidth cal utilization 0.4 =  4/10 = 2/5  --> clk * 2 * buswidth(16bits) * 0.4 /8
-	VIDEO_DBG("m clk = %d \n",ast_video->plat_data->get_clk());
-	ast_video->bandwidth = (ast_video->plat_data->get_clk() /10) * 16;
-	VIDEO_DBG("Memory Bandwidth = %d Byte/s\n", ast_video->bandwidth);
-
-//	ast_video->timeout = 5;	
-	ast_video->flag = 0;
-	init_waitqueue_head(&ast_video->video_wq);
-
-	//workqueue
-	init_waitqueue_head (&my_queue);
-
 	ret = sysfs_create_group(&pdev->dev.kobj, &video_attribute_group);
 	if (ret)
-		goto out_irq;
+		goto out_misc;
 
 
-	for(i=0;i<2;i++) {
+	for (i = 0; i < 2; i++) {
 		ret = sysfs_create_group(&pdev->dev.kobj, &compress_attribute_groups[i]);
 		if (ret)
-			goto out_irq;
+			goto out_create_groups;
 	}
 
 	platform_set_drvdata(pdev, ast_video);
@@ -2459,38 +3264,41 @@ static int ast_video_probe(struct platform_device *pdev)
 
 	ast_video_ctrl_init(ast_video);
 
-	ret = request_irq(ast_video->irq, video_interrupt, 0, "ast-video", ast_video);
+
+	ret = devm_request_irq(&pdev->dev, ast_video->irq, ast_video_isr,
+						   0, dev_name(&pdev->dev), ast_video);
+
 	if (ret) {
 		printk(KERN_INFO "VIDEO: Failed request irq %d\n", ast_video->irq);
-		goto out_region1;
+		goto out_create_groups;
 	}
 
 #if 0
-       ast_video->thread_task = kthread_create(ast_video_thread, (void *) ast_video, "ast-video-kthread");
-        if (IS_ERR(ast_video->thread_task)) {
-                printk("ast video cannot create kthread\n");
-                ret = PTR_ERR(ast_video->thread_task);
-                goto out_irq;
-        }
+	ast_video->thread_task = kthread_create(ast_video_thread, (void *) ast_video, "ast-video-kthread");
+	if (IS_ERR(ast_video->thread_task)) {
+		printk("ast video cannot create kthread\n");
+		ret = PTR_ERR(ast_video->thread_task);
+		goto out_create_groups;
+	}
 
 	VIDEO_DBG("kthread pid: %d\n", ast_video->thread_task->pid);
-#endif			
+#endif
+
 
 
-		
 	printk(KERN_INFO "ast_video: driver successfully loaded.\n");
 
 	return 0;
 
-out_irq:
-	free_irq(ast_video->irq, NULL);
+out_create_groups:
+	sysfs_remove_group(&pdev->dev.kobj, &compress_attribute_groups[0]);
+	sysfs_remove_group(&pdev->dev.kobj, &video_attribute_group);
 
-out_region1:
-	release_mem_region(res1->start, res1->end - res1->start + 1);	
+out_misc:
+	misc_deregister(&ast_video_misc);
 
-out_region0:
-	release_mem_region(res0->start, res0->end - res0->start + 1);
-	
+out_region1:
+	iounmap(ast_video->stream_virt);
 out:
 	printk(KERN_WARNING "applesmc: driver init failed (ret=%d)!\n", ret);
 	return ret;
@@ -2499,38 +3307,32 @@ out:
 
 static int ast_video_remove(struct platform_device *pdev)
 {
-	struct resource *res0, *res1;
 	struct ast_video_data *ast_video = platform_get_drvdata(pdev);
+	int i;
 	VIDEO_DBG("ast_video_remove\n");
 
 	misc_deregister(&ast_video_misc);
 
-	free_irq(ast_video->irq, ast_video);
-
-	res0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-
-	iounmap(ast_video->reg_base);
-
-	release_mem_region(res0->start, res0->end - res0->start + 1);
-
-	res1 = platform_get_resource(pdev, IORESOURCE_DMA, 0);
-
-	iounmap(ast_video->stream_virt);
+	sysfs_remove_group(&pdev->dev.kobj, &video_attribute_group);
+	for (i = 0; i < 2; i++) {
+		sysfs_remove_group(&pdev->dev.kobj, &compress_attribute_groups[i]);
+	}
 
-	release_mem_region(res1->start, res1->end - res1->start + 1);
+	if (ast_video->stream_virt)
+		iounmap(ast_video->stream_virt);
 
-	return 0;	
+	return 0;
 }
 
 #ifdef CONFIG_PM
-static int 
+static int
 ast_video_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	printk("ast_video_suspend : TODO \n");
 	return 0;
 }
 
-static int 
+static int
 ast_video_resume(struct platform_device *pdev)
 {
 	return 0;
@@ -2541,28 +3343,53 @@ ast_video_resume(struct platform_device *pdev)
 #define ast_video_resume         NULL
 #endif
 
+// static struct platform_driver ast_video_driver = {
+// 	.probe 		= ast_video_probe,
+// 	.remove 		= ast_video_remove,
+// #ifdef CONFIG_PM
+// 	.suspend        = ast_video_suspend,
+// 	.resume         = ast_video_resume,
+// #endif
+// 	.driver  	       = {
+// 		.name   = KBUILD_MODNAME,
+// 		.of_match_table = aspeed_video_matches,
+// 	},
+// };
+
+// module_platform_driver(ast_video_driver);
+
+
+
+
+
 static const struct platform_device_id ast_video_idtable[] = {
-	{
-		.name = "ast-video",
-//		.driver_data = ast_video_data,
-		/* sentinel */
-	}
+    {
+        .name = "ast-video",
+        // .driver_data = ast_video_data,
+        /* sentinel */
+    }
 };
 MODULE_DEVICE_TABLE(platform, ast_video_idtable);
 
 static struct platform_driver ast_video_driver = {
-	.remove 		= ast_video_remove,
-	.suspend        = ast_video_suspend,
-	.resume         = ast_video_resume,
-	.driver  	       = {
-	        .name   = "ast-video",
-	        .owner  = THIS_MODULE,
-	},
-	.id_table	= ast_video_idtable,	
+    .remove         = ast_video_remove,
+    .suspend        = ast_video_suspend,
+    .resume         = ast_video_resume,
+    .driver            = {
+            .name   = "ast-video",
+            .owner  = THIS_MODULE,
+    },
+    .id_table   = ast_video_idtable,
 };
 
 module_platform_driver_probe(ast_video_driver, ast_video_probe);
 
+
+
+
+
+
+
 MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
 MODULE_DESCRIPTION("AST Video Engine driver");
 MODULE_LICENSE("GPL");
diff --git a/include/linux/aspeed-sdmc.h b/include/linux/aspeed-sdmc.h
new file mode 100644
index 0000000..b7d99b9
--- /dev/null
+++ b/include/linux/aspeed-sdmc.h
@@ -0,0 +1,30 @@
+/********************************************************************************
+* File Name     : arch/arm/mach-aspeed/include/plat/ast-sdmc.h
+* Author        : Ryan Chen
+* Description   : AST SDMC Header
+*
+* Copyright (C) 2012-2020  ASPEED Technology Inc.
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by the Free Software Foundation;
+* either version 2 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*   History      :
+*      1. 2012/08/03 Ryan Chen create this file
+*
+********************************************************************************/
+
+#ifndef __AST_SDMC_H_INCLUDED
+#define __AST_SDMC_H_INCLUDED
+
+extern u32 ast_sdmc_get_mem_size(void);
+extern u8 ast_sdmc_get_ecc(void);
+extern u8 ast_sdmc_get_cache(void);
+extern void ast_sdmc_disable_mem_protection(u8 req);
+
+#endif
diff --git a/include/linux/ast_lcd.h b/include/linux/ast_lcd.h
new file mode 100644
index 0000000..8b4eaa1
--- /dev/null
+++ b/include/linux/ast_lcd.h
@@ -0,0 +1,54 @@
+/*
+* ast_lcd.h - ASPEED LCD Panel Timing 
+*
+* Copyright (C) ASPEED Technology Inc.
+* Ryan Chen <ryan_chen@aspeedtech.com>
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License
+* as published by the Free Software Foundation; either version
+* 2 of the License, or (at your option) any later version.
+*/
+#include <linux/fb.h>
+
+//# Define IO __ for control 
+#define YUV_MODE 0x4630
+#define CHANGE_YUV_ADDR 0x4631
+#define CHANGE_ADDR 0x4632
+#define OVERSCAN 0x4634
+
+
+enum astfb_color_format {
+	ASTFB_COLOR_NONE = 0,
+	ASTFB_COLOR_RGB565,
+	ASTFB_COLOR_RGB888,
+	ASTFB_COLOR_YUV444,
+	ASTFB_COLOR_YUV420,
+	ASTFB_COLOR_YUV422,	
+};
+
+struct aspeed_lcd_panel {
+	struct fb_videomode	mode;
+	signed short		width;	/* width in mm */
+	signed short		height;	/* height in mm */
+};
+
+struct ast_monitor_info {
+	int status; //0: no data   1:get data
+	int type;   //0:dvi  1:hdmi
+	struct fb_monspecs specs;
+	char edid[256];
+};
+
+struct ast_fb_plat_data {
+#ifdef CONFIG_MACH_ASPEED_G5
+	void (*set_pll)(u32 pll_setting);
+	u32 clock_src;	//0: 24Mhz, 1: 25Mhz
+#endif
+	int disp_dev_no;
+};
+
+int ast_vga_get_info(struct fb_info *fb_info);
+int ast_hdmi_get_info(struct fb_info *fb_info);
+void ast_hdmi_enable(int en);
+int vga_read_edid(void);
diff --git a/include/linux/reset.h b/include/linux/reset.h
index da5602b..5daff15 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -1,8 +1,8 @@
 #ifndef _LINUX_RESET_H_
 #define _LINUX_RESET_H_
 
-struct device;
-struct device_node;
+#include <linux/device.h>
+
 struct reset_control;
 
 #ifdef CONFIG_RESET_CONTROLLER
@@ -12,9 +12,11 @@ int reset_control_assert(struct reset_control *rstc);
 int reset_control_deassert(struct reset_control *rstc);
 int reset_control_status(struct reset_control *rstc);
 
-struct reset_control *reset_control_get(struct device *dev, const char *id);
+struct reset_control *__of_reset_control_get(struct device_node *node,
+				     const char *id, int index, int shared);
 void reset_control_put(struct reset_control *rstc);
-struct reset_control *devm_reset_control_get(struct device *dev, const char *id);
+struct reset_control *__devm_reset_control_get(struct device *dev,
+				     const char *id, int index, int shared);
 
 int __must_check device_reset(struct device *dev);
 
@@ -23,21 +25,6 @@ static inline int device_reset_optional(struct device *dev)
 	return device_reset(dev);
 }
 
-static inline struct reset_control *reset_control_get_optional(
-					struct device *dev, const char *id)
-{
-	return reset_control_get(dev, id);
-}
-
-static inline struct reset_control *devm_reset_control_get_optional(
-					struct device *dev, const char *id)
-{
-	return devm_reset_control_get(dev, id);
-}
-
-struct reset_control *of_reset_control_get(struct device_node *node,
-					   const char *id);
-
 #else
 
 static inline int reset_control_reset(struct reset_control *rstc)
@@ -69,29 +56,314 @@ static inline void reset_control_put(struct reset_control *rstc)
 	WARN_ON(1);
 }
 
+static inline int __must_check device_reset(struct device *dev)
+{
+	WARN_ON(1);
+	return -ENOTSUPP;
+}
+
 static inline int device_reset_optional(struct device *dev)
 {
-	return -ENOSYS;
+	return -ENOTSUPP;
 }
 
-static inline struct reset_control *reset_control_get_optional(
+static inline struct reset_control *__of_reset_control_get(
+					struct device_node *node,
+					const char *id, int index, int shared)
+{
+	return ERR_PTR(-ENOTSUPP);
+}
+
+static inline struct reset_control *__devm_reset_control_get(
+					struct device *dev,
+					const char *id, int index, int shared)
+{
+	return ERR_PTR(-ENOTSUPP);
+}
+
+#endif /* CONFIG_RESET_CONTROLLER */
+
+/**
+ * reset_control_get_exclusive - Lookup and obtain an exclusive reference
+ *                               to a reset controller.
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ * If this function is called more then once for the same reset_control it will
+ * return -EBUSY.
+ *
+ * See reset_control_get_shared for details on shared references to
+ * reset-controls.
+ *
+ * Use of id names is optional.
+ */
+static inline struct reset_control *
+__must_check reset_control_get_exclusive(struct device *dev, const char *id)
+{
+#ifndef CONFIG_RESET_CONTROLLER
+	WARN_ON(1);
+#endif
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
+}
+
+/**
+ * reset_control_get_shared - Lookup and obtain a shared reference to a
+ *                            reset controller.
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ * This function is intended for use with reset-controls which are shared
+ * between hardware-blocks.
+ *
+ * When a reset-control is shared, the behavior of reset_control_assert /
+ * deassert is changed, the reset-core will keep track of a deassert_count
+ * and only (re-)assert the reset after reset_control_assert has been called
+ * as many times as reset_control_deassert was called. Also see the remark
+ * about shared reset-controls in the reset_control_assert docs.
+ *
+ * Calling reset_control_assert without first calling reset_control_deassert
+ * is not allowed on a shared reset control. Calling reset_control_reset is
+ * also not allowed on a shared reset control.
+ *
+ * Use of id names is optional.
+ */
+static inline struct reset_control *reset_control_get_shared(
 					struct device *dev, const char *id)
 {
-	return ERR_PTR(-ENOSYS);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 1);
 }
 
-static inline struct reset_control *devm_reset_control_get_optional(
+static inline struct reset_control *reset_control_get_optional_exclusive(
+					struct device *dev, const char *id)
+{
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
+}
+
+static inline struct reset_control *reset_control_get_optional_shared(
 					struct device *dev, const char *id)
 {
-	return ERR_PTR(-ENOSYS);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 1);
+}
+
+/**
+ * of_reset_control_get_exclusive - Lookup and obtain an exclusive reference
+ *                                  to a reset controller.
+ * @node: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ *
+ * Use of id names is optional.
+ */
+static inline struct reset_control *of_reset_control_get_exclusive(
+				struct device_node *node, const char *id)
+{
+	return __of_reset_control_get(node, id, 0, 0);
+}
+
+/**
+ * of_reset_control_get_shared - Lookup and obtain an shared reference
+ *                               to a reset controller.
+ * @node: device to be reset by the controller
+ * @id: reset line name
+ *
+ * When a reset-control is shared, the behavior of reset_control_assert /
+ * deassert is changed, the reset-core will keep track of a deassert_count
+ * and only (re-)assert the reset after reset_control_assert has been called
+ * as many times as reset_control_deassert was called. Also see the remark
+ * about shared reset-controls in the reset_control_assert docs.
+ *
+ * Calling reset_control_assert without first calling reset_control_deassert
+ * is not allowed on a shared reset control. Calling reset_control_reset is
+ * also not allowed on a shared reset control.
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ *
+ * Use of id names is optional.
+ */
+static inline struct reset_control *of_reset_control_get_shared(
+				struct device_node *node, const char *id)
+{
+	return __of_reset_control_get(node, id, 0, 1);
+}
+
+/**
+ * of_reset_control_get_exclusive_by_index - Lookup and obtain an exclusive
+ *                                           reference to a reset controller
+ *                                           by index.
+ * @node: device to be reset by the controller
+ * @index: index of the reset controller
+ *
+ * This is to be used to perform a list of resets for a device or power domain
+ * in whatever order. Returns a struct reset_control or IS_ERR() condition
+ * containing errno.
+ */
+static inline struct reset_control *of_reset_control_get_exclusive_by_index(
+					struct device_node *node, int index)
+{
+	return __of_reset_control_get(node, NULL, index, 0);
+}
+
+/**
+ * of_reset_control_get_shared_by_index - Lookup and obtain an shared
+ *                                        reference to a reset controller
+ *                                        by index.
+ * @node: device to be reset by the controller
+ * @index: index of the reset controller
+ *
+ * When a reset-control is shared, the behavior of reset_control_assert /
+ * deassert is changed, the reset-core will keep track of a deassert_count
+ * and only (re-)assert the reset after reset_control_assert has been called
+ * as many times as reset_control_deassert was called. Also see the remark
+ * about shared reset-controls in the reset_control_assert docs.
+ *
+ * Calling reset_control_assert without first calling reset_control_deassert
+ * is not allowed on a shared reset control. Calling reset_control_reset is
+ * also not allowed on a shared reset control.
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ *
+ * This is to be used to perform a list of resets for a device or power domain
+ * in whatever order. Returns a struct reset_control or IS_ERR() condition
+ * containing errno.
+ */
+static inline struct reset_control *of_reset_control_get_shared_by_index(
+					struct device_node *node, int index)
+{
+	return __of_reset_control_get(node, NULL, index, 1);
+}
+
+/**
+ * devm_reset_control_get_exclusive - resource managed
+ *                                    reset_control_get_exclusive()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Managed reset_control_get_exclusive(). For reset controllers returned
+ * from this function, reset_control_put() is called automatically on driver
+ * detach.
+ *
+ * See reset_control_get_exclusive() for more information.
+ */
+static inline struct reset_control *
+__must_check devm_reset_control_get_exclusive(struct device *dev,
+					      const char *id)
+{
+#ifndef CONFIG_RESET_CONTROLLER
+	WARN_ON(1);
+#endif
+	return __devm_reset_control_get(dev, id, 0, 0);
+}
+
+/**
+ * devm_reset_control_get_shared - resource managed reset_control_get_shared()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Managed reset_control_get_shared(). For reset controllers returned from
+ * this function, reset_control_put() is called automatically on driver detach.
+ * See reset_control_get_shared() for more information.
+ */
+static inline struct reset_control *devm_reset_control_get_shared(
+					struct device *dev, const char *id)
+{
+	return __devm_reset_control_get(dev, id, 0, 1);
+}
+
+static inline struct reset_control *devm_reset_control_get_optional_exclusive(
+					struct device *dev, const char *id)
+{
+	return __devm_reset_control_get(dev, id, 0, 0);
+}
+
+static inline struct reset_control *devm_reset_control_get_optional_shared(
+					struct device *dev, const char *id)
+{
+	return __devm_reset_control_get(dev, id, 0, 1);
+}
+
+/**
+ * devm_reset_control_get_exclusive_by_index - resource managed
+ *                                             reset_control_get_exclusive()
+ * @dev: device to be reset by the controller
+ * @index: index of the reset controller
+ *
+ * Managed reset_control_get_exclusive(). For reset controllers returned from
+ * this function, reset_control_put() is called automatically on driver
+ * detach.
+ *
+ * See reset_control_get_exclusive() for more information.
+ */
+static inline struct reset_control *
+devm_reset_control_get_exclusive_by_index(struct device *dev, int index)
+{
+	return __devm_reset_control_get(dev, NULL, index, 0);
+}
+
+/**
+ * devm_reset_control_get_shared_by_index - resource managed
+ * reset_control_get_shared
+ * @dev: device to be reset by the controller
+ * @index: index of the reset controller
+ *
+ * Managed reset_control_get_shared(). For reset controllers returned from
+ * this function, reset_control_put() is called automatically on driver detach.
+ * See reset_control_get_shared() for more information.
+ */
+static inline struct reset_control *
+devm_reset_control_get_shared_by_index(struct device *dev, int index)
+{
+	return __devm_reset_control_get(dev, NULL, index, 1);
+}
+
+/*
+ * TEMPORARY calls to use during transition:
+ *
+ *   of_reset_control_get() => of_reset_control_get_exclusive()
+ *
+ * These inline function calls will be removed once all consumers
+ * have been moved over to the new explicit API.
+ */
+static inline struct reset_control *reset_control_get(
+				struct device *dev, const char *id)
+{
+	return reset_control_get_exclusive(dev, id);
+}
+
+static inline struct reset_control *reset_control_get_optional(
+					struct device *dev, const char *id)
+{
+	return reset_control_get_optional_exclusive(dev, id);
 }
 
 static inline struct reset_control *of_reset_control_get(
 				struct device_node *node, const char *id)
 {
-	return ERR_PTR(-ENOSYS);
+	return of_reset_control_get_exclusive(node, id);
 }
 
-#endif /* CONFIG_RESET_CONTROLLER */
+static inline struct reset_control *of_reset_control_get_by_index(
+				struct device_node *node, int index)
+{
+	return of_reset_control_get_exclusive_by_index(node, index);
+}
+
+static inline struct reset_control *devm_reset_control_get(
+				struct device *dev, const char *id)
+{
+	return devm_reset_control_get_exclusive(dev, id);
+}
 
+static inline struct reset_control *devm_reset_control_get_optional(
+				struct device *dev, const char *id)
+{
+	return devm_reset_control_get_optional_exclusive(dev, id);
+
+}
+
+static inline struct reset_control *devm_reset_control_get_by_index(
+				struct device *dev, int index)
+{
+	return devm_reset_control_get_exclusive_by_index(dev, index);
+}
 #endif
